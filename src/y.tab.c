#include <stdlib.h>
#ifndef lint
#ifdef __unused
__unused
#endif
static char const 
yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.37 2003/02/12 18:03:55 davidc Exp $";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING() (yyerrflag!=0)
#if defined(__cplusplus) || __STDC__
static int yygrowstack(void);
#else
static int yygrowstack();
#endif
#define YYPREFIX "yy"
#line 26 "ircd_parser.y"

#define YY_NO_UNPUT
#include <sys/types.h>

#include "stdinc.h"
#include "ircd.h"
#include "s_conf.h"
#include "client.h"	/* for UMODE_ALL only */
#include "modules.h"
#include "s_serv.h" /* for CAP_LL / IsCapable */
#include "hostmask.h"
#include "send.h"
#include "listener.h"
#include "resv.h"
#include "numeric.h"
#include "s_user.h"

#ifdef HAVE_LIBCRYPTO
#include <openssl/rsa.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#endif

static char *class_name = NULL;
static struct ConfItem *yy_conf = NULL;
static struct AccessItem *yy_aconf = NULL;
static struct MatchItem *yy_match_item = NULL;
static struct ClassItem *yy_class = NULL;
static char *yy_class_name = NULL;

static dlink_list col_conf_list  = { NULL, NULL, 0 };
static dlink_list hub_conf_list  = { NULL, NULL, 0 };
static dlink_list leaf_conf_list = { NULL, NULL, 0 };
static unsigned int listener_flags = 0;
static unsigned int regex_ban = 0;
static char userbuf[IRCD_BUFSIZE];
static char hostbuf[IRCD_BUFSIZE];
static char reasonbuf[REASONLEN + 1];
static char gecos_name[REALLEN * 4];

EXTERN dlink_list gdeny_items; /* XXX */

static char *resv_reason = NULL;
static char *listener_address = NULL;
static int not_atom = 0;

struct CollectItem {
  dlink_node node;
  char *name;
  char *user;
  char *host;
  char *passwd;
  int  port;
  int  flags;
#ifdef HAVE_LIBCRYPTO
  char *rsa_public_key_file;
  RSA *rsa_public_key;
#endif
};

static void
free_collect_item(struct CollectItem *item)
{
  MyFree(item->name);
  MyFree(item->user);
  MyFree(item->host);
  MyFree(item->passwd);
#ifdef HAVE_LIBCRYPTO
  MyFree(item->rsa_public_key_file);
#endif
  MyFree(item);
}

static void
unhook_hub_leaf_confs(void)
{
  dlink_node *ptr;
  dlink_node *next_ptr;
  struct CollectItem *yy_hconf;
  struct CollectItem *yy_lconf;

  DLINK_FOREACH_SAFE(ptr, next_ptr, hub_conf_list.head)
  {
    yy_hconf = ptr->data;
    dlinkDelete(&yy_hconf->node, &hub_conf_list);
    free_collect_item(yy_hconf);
  }

  DLINK_FOREACH_SAFE(ptr, next_ptr, leaf_conf_list.head)
  {
    yy_lconf = ptr->data;
    dlinkDelete(&yy_lconf->node, &leaf_conf_list);
    free_collect_item(yy_lconf);
  }
}

#line 124 "ircd_parser.y"
typedef union {
  int number;
  char *string;
} YYSTYPE;
#line 126 "y.tab.c"
#define YYERRCODE 256
#define ACCEPT_PASSWORD 257
#define ACTION 258
#define ADMIN 259
#define AFTYPE 260
#define T_ALLOW 261
#define ANTI_NICK_FLOOD 262
#define ANTI_SPAM_EXIT_MESSAGE_TIME 263
#define AUTOCONN 264
#define T_BLOCK 265
#define BURST_AWAY 266
#define BURST_TOPICWHO 267
#define BYTES 268
#define KBYTES 269
#define MBYTES 270
#define GBYTES 271
#define TBYTES 272
#define CALLER_ID_WAIT 273
#define CAN_FLOOD 274
#define CAN_IDLE 275
#define CHANNEL 276
#define CIDR_BITLEN_IPV4 277
#define CIDR_BITLEN_IPV6 278
#define CIPHER_PREFERENCE 279
#define CLASS 280
#define COMPRESSED 281
#define COMPRESSION_LEVEL 282
#define CONNECT 283
#define CONNECTFREQ 284
#define CRYPTLINK 285
#define DEFAULT_CIPHER_PREFERENCE 286
#define DEFAULT_FLOODCOUNT 287
#define DEFAULT_SPLIT_SERVER_COUNT 288
#define DEFAULT_SPLIT_USER_COUNT 289
#define DENY 290
#define DESCRIPTION 291
#define DIE 292
#define DISABLE_AUTH 293
#define DISABLE_HIDDEN 294
#define DISABLE_LOCAL_CHANNELS 295
#define DISABLE_REMOTE_COMMANDS 296
#define DOT_IN_IP6_ADDR 297
#define DOTS_IN_IDENT 298
#define DURATION 299
#define EGDPOOL_PATH 300
#define EMAIL 301
#define ENABLE 302
#define ENCRYPTED 303
#define EXCEED_LIMIT 304
#define EXEMPT 305
#define FAILED_OPER_NOTICE 306
#define FAKENAME 307
#define IRCD_FLAGS 308
#define FLATTEN_LINKS 309
#define FFAILED_OPERLOG 310
#define FKILLLOG 311
#define FKLINELOG 312
#define FGLINELOG 313
#define FIOERRLOG 314
#define FOPERLOG 315
#define FOPERSPYLOG 316
#define FUSERLOG 317
#define GECOS 318
#define GENERAL 319
#define GLINE 320
#define GLINES 321
#define GLINE_EXEMPT 322
#define GLINE_LOG 323
#define GLINE_TIME 324
#define GLINE_MIN_CIDR 325
#define GLINE_MIN_CIDR6 326
#define GLOBAL_KILL 327
#define IRCD_AUTH 328
#define NEED_IDENT 329
#define HAVENT_READ_CONF 330
#define HIDDEN 331
#define HIDDEN_ADMIN 332
#define HIDDEN_NAME 333
#define HIDDEN_OPER 334
#define HIDE_SERVER_IPS 335
#define HIDE_SERVERS 336
#define HIDE_SPOOF_IPS 337
#define HOST 338
#define HUB 339
#define HUB_MASK 340
#define IDLETIME 341
#define IGNORE_BOGUS_TS 342
#define INVISIBLE_ON_CONNECT 343
#define IP 344
#define KILL 345
#define KILL_CHASE_TIME_LIMIT 346
#define KLINE 347
#define KLINE_EXEMPT 348
#define KLINE_REASON 349
#define KLINE_WITH_REASON 350
#define KNOCK_DELAY 351
#define KNOCK_DELAY_CHANNEL 352
#define LAZYLINK 353
#define LEAF_MASK 354
#define LINKS_DELAY 355
#define LISTEN 356
#define T_LOG 357
#define LOGGING 358
#define LOG_LEVEL 359
#define MAX_ACCEPT 360
#define MAX_BANS 361
#define MAX_CHANS_PER_USER 362
#define MAX_GLOBAL 363
#define MAX_IDENT 364
#define MAX_LOCAL 365
#define MAX_NICK_CHANGES 366
#define MAX_NICK_TIME 367
#define MAX_NUMBER 368
#define MAX_TARGETS 369
#define MAX_WATCH 370
#define MESSAGE_LOCALE 371
#define MIN_NONWILDCARD 372
#define MIN_NONWILDCARD_SIMPLE 373
#define MODULE 374
#define MODULES 375
#define NAME 376
#define NEED_PASSWORD 377
#define NETWORK_DESC 378
#define NETWORK_NAME 379
#define NICK 380
#define NICK_CHANGES 381
#define NO_CREATE_ON_SPLIT 382
#define NO_JOIN_ON_SPLIT 383
#define NO_OPER_FLOOD 384
#define NO_TILDE 385
#define NOT 386
#define NUMBER 387
#define NUMBER_PER_IDENT 388
#define NUMBER_PER_CIDR 389
#define NUMBER_PER_IP 390
#define NUMBER_PER_IP_GLOBAL 391
#define OPERATOR 392
#define OPERS_BYPASS_CALLERID 393
#define OPER_LOG 394
#define OPER_ONLY_UMODES 395
#define OPER_PASS_RESV 396
#define OPER_SPY_T 397
#define OPER_UMODES 398
#define JOIN_FLOOD_COUNT 399
#define JOIN_FLOOD_TIME 400
#define PACE_WAIT 401
#define PACE_WAIT_SIMPLE 402
#define PASSWORD 403
#define PATH 404
#define PING_COOKIE 405
#define PING_TIME 406
#define PING_WARNING 407
#define PORT 408
#define QSTRING 409
#define QUIET_ON_BAN 410
#define REASON 411
#define REDIRPORT 412
#define REDIRSERV 413
#define REGEX_T 414
#define REHASH 415
#define TREJECT_HOLD_TIME 416
#define REMOTE 417
#define REMOTEBAN 418
#define RESTRICT_CHANNELS 419
#define RESTRICTED 420
#define RSA_PRIVATE_KEY_FILE 421
#define RSA_PUBLIC_KEY_FILE 422
#define SSL_CERTIFICATE_FILE 423
#define RESV 424
#define RESV_EXEMPT 425
#define SECONDS 426
#define MINUTES 427
#define HOURS 428
#define DAYS 429
#define WEEKS 430
#define SENDQ 431
#define SEND_PASSWORD 432
#define SERVERHIDE 433
#define SERVERINFO 434
#define SERVLINK_PATH 435
#define IRCD_SID 436
#define TKLINE_EXPIRE_NOTICES 437
#define T_SHARED 438
#define T_CLUSTER 439
#define TYPE 440
#define SHORT_MOTD 441
#define SILENT 442
#define SPOOF 443
#define SPOOF_NOTICE 444
#define STATS_I_OPER_ONLY 445
#define STATS_K_OPER_ONLY 446
#define STATS_O_OPER_ONLY 447
#define STATS_P_OPER_ONLY 448
#define TBOOL 449
#define TMASKED 450
#define T_REJECT 451
#define TS_MAX_DELTA 452
#define TS_WARN_DELTA 453
#define TWODOTS 454
#define T_ALL 455
#define T_BOTS 456
#define T_SOFTCALLERID 457
#define T_CALLERID 458
#define T_CCONN 459
#define T_CLIENT_FLOOD 460
#define T_DEAF 461
#define T_DEBUG 462
#define T_DRONE 463
#define T_EXTERNAL 464
#define T_FULL 465
#define T_INVISIBLE 466
#define T_IPV4 467
#define T_IPV6 468
#define T_LOCOPS 469
#define T_LOGPATH 470
#define T_L_CRIT 471
#define T_L_DEBUG 472
#define T_L_ERROR 473
#define T_L_INFO 474
#define T_L_NOTICE 475
#define T_L_TRACE 476
#define T_L_WARN 477
#define T_MAX_CLIENTS 478
#define T_NCHANGE 479
#define T_OPERWALL 480
#define T_REJ 481
#define T_SERVNOTICE 482
#define T_SKILL 483
#define T_SPY 484
#define T_SSL 485
#define T_UMODES 486
#define T_UNAUTH 487
#define T_UNRESV 488
#define T_UNXLINE 489
#define T_WALLOP 490
#define THROTTLE_TIME 491
#define TOPICBURST 492
#define TRUE_NO_OPER_FLOOD 493
#define TKLINE 494
#define TXLINE 495
#define TRESV 496
#define UNKLINE 497
#define USER 498
#define USE_EGD 499
#define USE_EXCEPT 500
#define USE_INVEX 501
#define USE_KNOCK 502
#define USE_LOGGING 503
#define USE_WHOIS_ACTUALLY 504
#define VHOST 505
#define VHOST6 506
#define XLINE 507
#define WARN 508
#define WARN_NO_NLINE 509
const short yylhs[] = {                                        -1,
    0,    0,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    2,    2,    1,    1,    1,    1,
    1,    1,    4,    4,    3,    3,    3,    3,   25,   26,
   26,   27,   27,   27,   28,   29,   13,   30,   30,   31,
   31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
   31,   42,   39,   32,   41,   35,   36,   37,   33,   40,
   38,   34,    6,   43,   43,   44,   44,   44,   44,   45,
   47,   46,    7,   48,   48,   49,   49,   49,   49,   49,
   49,   49,   49,   49,   49,   49,   49,   49,   50,   51,
   54,   61,   55,   59,   56,   57,   60,   58,   52,   52,
   52,   52,   52,   52,   52,   53,   63,    8,   62,   62,
   64,   64,   66,   66,   66,   66,   66,   66,   66,   66,
   66,   66,   66,   66,   66,   66,   66,   66,   66,   66,
   66,   66,   66,   66,   66,   67,   65,   68,   69,   86,
   87,   73,   89,   72,   90,   90,   91,   91,   91,   91,
   91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
   91,   91,   91,   91,   74,   75,   81,   76,   77,   78,
   79,   80,   82,   83,   84,   70,   71,   85,   92,   88,
   93,   93,   96,   94,   97,   94,   95,   95,   95,   95,
   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
   95,   95,   99,   10,   98,   98,  100,  100,  102,  102,
  102,  102,  102,  102,  102,  102,  102,  102,  102,  102,
  102,  102,  103,  101,  106,  107,  109,  110,  111,  112,
  113,  114,  115,  104,  105,  108,  116,   11,  119,  118,
  120,  120,  121,  121,  117,  117,  122,  122,  122,  122,
  122,  123,  126,  126,  127,  127,  124,  125,  128,   12,
  129,  129,  130,  130,  130,  130,  130,  130,  130,  130,
  130,  130,  130,  130,  130,  130,  130,  130,  130,  131,
  132,  141,  133,  146,  147,  134,  148,  148,  151,  149,
  152,  149,  150,  150,  150,  150,  150,  150,  150,  150,
  150,  150,  135,  136,  137,  144,  138,  139,  140,  142,
  143,  145,  153,   15,  154,  154,  155,  155,  155,  155,
  156,  157,  158,  159,   16,  160,  160,  161,  161,  161,
  161,  162,  163,  165,  164,  166,  166,  167,  167,  167,
  167,  167,  167,  167,  167,  167,  167,  167,  168,   17,
  169,  169,  170,  170,  170,  171,  173,  172,  174,  174,
  175,  175,  175,  175,  175,  175,  175,  175,  175,  175,
  175,  177,   18,  176,  176,  178,  178,  180,  180,  180,
  180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
  180,  180,  180,  180,  180,  180,  181,  179,  182,  183,
  184,  185,  187,  186,  186,  188,  199,  189,  200,  200,
  203,  201,  204,  201,  202,  202,  202,  202,  202,  202,
  197,  194,  196,  195,  193,  190,  191,  192,  198,  205,
   19,  208,  207,  209,  209,  210,  206,  206,  211,  211,
  211,  211,  212,  213,  214,   20,  215,  215,  216,  216,
  216,  217,  218,   21,  219,  219,  220,  220,  221,  222,
   24,  225,  224,  226,  226,  227,  223,  223,  228,  228,
  228,  228,  229,  230,   22,  231,  231,  232,  232,  232,
  232,  232,  232,  232,  232,  232,  232,  232,  232,  232,
  232,  232,  232,  232,  232,  232,  232,  232,  232,  232,
  232,  232,  232,  232,  232,  232,  232,  232,  232,  232,
  232,  232,  232,  232,  232,  232,  232,  232,  232,  232,
  232,  232,  232,  232,  232,  232,  232,  232,  232,  232,
  232,  232,  232,  287,  283,  284,  281,  285,  286,  282,
  243,  233,  234,  272,  235,  236,  237,  238,  239,  240,
  241,  242,  277,  244,  245,  246,  247,  249,  254,  250,
  250,  252,  252,  251,  266,  267,  253,  255,  256,  257,
  258,  260,  259,  248,  262,  271,  273,  274,  263,  264,
  279,  280,  276,  288,  265,  289,  289,  290,  290,  290,
  290,  290,  290,  290,  290,  290,  290,  290,  290,  290,
  290,  290,  290,  290,  290,  291,  261,  292,  292,  293,
  293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
  293,  293,  293,  293,  293,  293,  293,  269,  270,  268,
  275,  278,  294,   23,  295,  295,  296,  296,  296,  296,
  296,  296,  296,  297,  298,  303,  299,  304,  304,  305,
  305,  300,  301,  306,  302,  307,  307,  308,  308,    9,
  309,  309,  310,  310,  310,  310,  310,  310,  310,  310,
  310,  310,  310,  310,  310,  310,  310,  310,  310,  310,
  323,  311,  312,  313,  314,  316,  317,  318,  319,  315,
  320,  321,  322,  324,  325,  326,  327,   14,  328,  328,
  329,  329,  329,  329,  329,  329,  329,  329,  330,  331,
  335,  332,  334,  333,  336,
};
const short yylen[] = {                                         2,
    0,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    2,    2,    0,    1,    2,    3,    3,    3,
    3,    3,    0,    1,    2,    3,    3,    3,    5,    2,
    1,    1,    1,    2,    4,    4,    5,    2,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    2,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    5,    2,    1,    1,    1,    1,    2,    4,
    4,    4,    5,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    2,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    7,    0,    1,
    2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    2,    4,    1,    4,    4,    4,
    4,    4,    0,    5,    3,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    0,    5,
    3,    1,    0,    3,    0,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    0,    7,    0,    1,    2,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    4,    1,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    6,    0,    5,
    3,    1,    1,    1,    2,    1,    1,    1,    1,    1,
    2,    4,    3,    1,    1,    3,    4,    4,    0,    6,
    2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    4,
    4,    4,    4,    4,    0,    5,    3,    1,    0,    3,
    0,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    0,    6,    2,    1,    1,    1,    1,    2,
    4,    4,    4,    0,    6,    2,    1,    1,    1,    1,
    2,    4,    4,    0,    5,    3,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    0,    6,
    2,    1,    1,    1,    2,    4,    0,    5,    3,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    0,    7,    0,    1,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    2,    4,    1,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    5,    3,    1,
    0,    3,    0,    2,    1,    1,    1,    1,    1,    1,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    0,
    6,    0,    5,    3,    1,    1,    2,    1,    1,    1,
    1,    1,    4,    4,    0,    6,    2,    1,    1,    1,
    1,    4,    4,    5,    2,    1,    1,    1,    4,    0,
    6,    0,    5,    3,    1,    1,    2,    1,    1,    1,
    1,    1,    4,    4,    5,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    0,    5,    3,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    0,    5,    3,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    4,    4,    4,
    4,    4,    0,    6,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    4,    4,    0,    5,    3,    1,    1,
    1,    4,    4,    0,    5,    3,    1,    1,    1,    5,
    2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    5,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    4,    4,
    4,    4,    4,    4,    4,
};
const short yydefred[] = {                                      1,
    0,    0,    0,    0,  213,  382,  455,    0,  470,    0,
  643,  269,  440,  247,    0,    0,  117,  323,    0,    0,
  334,  359,    2,    3,    4,    5,    6,    7,    8,    9,
   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
   20,   21,   22,   23,   24,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   75,   76,   77,   78,  690,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  672,  673,  674,  675,  676,  677,  678,
  679,  680,  681,  682,  683,  684,  685,  686,  687,  688,
  689,  234,    0,  216,  408,    0,  385,    0,  468,    0,
    0,  466,  467,    0,  543,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  616,    0,
  594,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  487,  488,  489,  490,  491,  492,  493,  494,  495,
  496,  497,  498,  499,  500,  501,  502,  503,  504,  505,
  506,  507,  508,  509,  510,  511,  512,  513,  514,  515,
  516,  517,  518,  519,  520,  521,  522,  523,  524,  525,
  526,  527,  528,  529,  530,  531,  532,  533,  534,  535,
  536,  537,  538,  539,  540,  541,  542,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   85,   86,   87,   88,   89,
   90,   91,   92,   93,   94,   95,   96,   97,    0,    0,
    0,    0,   41,   42,   43,  147,    0,  120,    0,  718,
    0,    0,    0,    0,    0,    0,    0,    0,  710,  711,
  712,  713,  714,  715,  716,  717,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   49,
   50,   51,   52,   53,   54,   55,   56,   57,   58,   59,
   60,    0,    0,   79,    0,    0,    0,    0,   74,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  671,    0,    0,
  461,    0,    0,    0,  458,  459,  460,    0,    0,  465,
  482,    0,    0,  472,    0,  481,  478,  479,  480,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  486,  653,  664,    0,    0,
  656,    0,    0,    0,  646,  647,  648,  649,  650,  651,
  652,    0,    0,    0,    0,    0,  295,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  272,
  273,  274,  275,  276,  277,  278,  279,  280,  281,  282,
  283,  284,  285,  286,  287,  288,  452,    0,  442,    0,
    0,  451,  448,  449,  450,    0,  249,    0,    0,    0,
    0,  258,  256,  257,  259,  260,   98,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   84,   44,    0,    0,    0,   40,    0,    0,    0,    0,
    0,    0,  326,  327,  328,  329,    0,    0,    0,    0,
    0,    0,    0,    0,  709,   61,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   48,    0,
    0,  344,    0,    0,  337,  338,  339,  340,    0,    0,
  367,    0,  362,  363,  364,    0,    0,    0,   73,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  670,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  218,  219,  220,  221,  222,  223,  224,
  225,  226,  227,  228,  229,  230,  231,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  417,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  387,  388,  389,
  390,  391,  392,  393,  394,  395,  396,  397,  398,  399,
  400,  401,  402,  403,  404,  405,    0,    0,    0,  457,
    0,  464,    0,    0,    0,    0,  477,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  485,    0,    0,    0,    0,
    0,    0,    0,  645,  289,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  271,    0,    0,    0,    0,  447,  261,    0,
    0,    0,    0,    0,  255,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   83,    0,    0,   39,    0,    0,    0,
    0,    0,  189,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  153,    0,    0,    0,
    0,  122,  123,  124,  125,  126,  127,  128,  129,  130,
  131,  132,  133,  134,  135,  136,  137,  138,  139,  140,
  141,  142,  143,  144,  330,    0,    0,    0,    0,  325,
    0,    0,    0,    0,    0,    0,    0,  708,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   47,
  341,    0,    0,    0,    0,  336,  365,    0,    0,    0,
  361,   82,   81,   80,  705,  702,  701,  692,    0,    0,
    0,    0,    0,   26,   27,  696,  697,  700,  698,  703,
  704,  706,  707,  699,  691,  693,  694,  695,  232,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  217,  406,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  386,    0,    0,  456,  469,    0,
    0,    0,  471,  556,  560,  547,  575,  588,  587,  640,
  592,  554,  642,  584,  590,  555,  545,  546,  563,  552,
  583,  553,  566,  551,  565,  564,  559,  558,  557,  585,
  544,  582,  638,  639,  579,  576,  620,  635,  636,  621,
  622,  623,  630,  624,  633,  637,  626,  631,  627,  632,
  625,  629,  628,  634,    0,  619,  581,  598,  613,  614,
  599,  600,  601,  608,  602,  611,  615,  604,  609,  605,
  610,  603,  607,  606,  612,    0,  597,  574,  577,  591,
  549,  586,  550,  578,  572,  573,  570,  571,  568,  569,
  562,  561,    0,    0,    0,   34,   35,  641,  593,  580,
  589,  548,  567,    0,    0,    0,    0,    0,    0,  644,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  270,    0,    0,    0,
  441,    0,    0,    0,    0,    0,  264,  248,  102,  108,
  106,  105,  107,  103,  104,  101,  109,  115,  110,  114,
  112,  113,  111,  100,   99,  116,   45,   46,  145,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  121,    0,    0,    0,  324,  724,  719,  723,
  721,  725,  720,  722,   66,   72,   64,   68,   67,   63,
   62,   65,   71,   69,   70,    0,    0,    0,  335,    0,
    0,  360,   28,   29,   30,   31,   32,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  214,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  383,  462,  463,  483,  484,  476,    0,  475,  617,    0,
  595,    0,   36,   37,   38,  669,  668,    0,  667,  655,
  654,  661,  660,    0,  659,  663,  662,  316,  293,  294,
  315,  299,    0,  298,    0,  318,  314,  313,  322,  317,
  291,  321,  320,  319,  292,  290,  454,  446,    0,  445,
  453,  254,  253,    0,  252,  268,  267,    0,  262,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  118,  332,  333,  331,  342,  348,  354,  358,
  357,  356,  353,  349,  352,  355,  350,  351,    0,  347,
  343,  366,  371,  377,  381,  380,  379,  376,  372,  375,
  378,  373,  374,    0,  370,  244,  245,  238,  240,  242,
  241,  239,  233,  246,  237,  235,  236,  243,  412,  414,
  415,  435,  439,  438,  434,  433,  432,  416,  421,    0,
  420,    0,  409,  436,  437,  407,  413,  431,  411,  410,
  473,    0,  618,  596,  665,    0,  657,    0,    0,  296,
    0,  307,  308,  304,  310,  306,  305,  312,  309,  311,
  303,  302,  443,    0,  250,    0,  266,  263,  185,  152,
  183,  150,  193,    0,  192,    0,  181,  175,  186,  187,
  178,  146,  182,  149,  184,  176,  177,  151,  188,  157,
  172,  173,  158,  159,  160,  167,  161,  170,  174,  163,
  168,  164,  169,  162,  166,  165,  171,    0,  156,  180,
  148,  179,  345,    0,  368,    0,    0,  418,    0,  428,
  429,  426,  427,  425,  430,  424,  474,  666,  658,  300,
  297,  444,  251,    0,  190,    0,  205,  203,  212,  202,
  197,  206,  210,  199,  207,  209,  204,  198,  211,  208,
  200,  201,  196,  154,    0,  346,  369,  422,  419,  194,
  191,  155,
};
const short yydgoto[] = {                                       1,
  884,  885, 1036, 1037,   23,   24,   25,   26,   27,   28,
   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
   39,   40,   41,   42,   43,  272,  273,  274,  275,  309,
  310,  311,  312,  313,  314,  315,  316,  317,  318,  319,
  320,  321,   70,   71,   72,   73,   74,  255,  256,  257,
  258,  259,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  277,   60,  811,  278,  812,  813,  814,  815,  816,
  817,  818,  819,  820,  821,  822,  823,  824,  825,  826,
  827,  828,  829,  830,  831,  832,  833,  834, 1118, 1408,
 1409, 1104, 1374, 1375, 1453, 1434, 1376,  113,   48,  603,
  114,  604,  605,  606,  607,  608,  609,  610,  611,  612,
  613,  614,  615,  616,  617,   57,  491,  492,  760, 1244,
 1245,  493,  494,  495,  496, 1076, 1077,   55,  459,  460,
  461,  462,  463,  464,  465,  466,  467,  468,  469,  470,
  471,  472,  473,  474,  475,  476,  740, 1223, 1224, 1362,
 1349, 1225,   61,  522,  523,  524,  525,  526,   64,  554,
  555,  556,  557,  558,  863, 1289, 1290,   65,  562,  563,
  564,  565,  869, 1304, 1305,  116,   49,  637,  117,  638,
  639,  640,  641,  642,  643,  644,  645,  646,  647,  648,
  649,  650,  651,  652,  653,  654,  655,  656,  925, 1330,
 1331, 1426, 1417, 1332,   56,  481,  482,  755, 1239, 1240,
  483,  484,  485,   50,  354,  355,  356,  357,  121,  122,
  123,   52,  365,  366,  665, 1197, 1198,  367,  368,  369,
  181,  182,  183,  184,  185,  186,  187,  188,  189,  190,
  191,  192,  193,  194,  195,  196,  197,  198,  199,  200,
  201,  202,  203,  204,  205,  206,  207,  208,  209,  210,
  211,  212,  213,  214,  215,  216,  217,  218,  219,  220,
  221,  222,  223,  224,  225,  226,  227,  228,  229,  230,
  231,  232,  233,  234,  235,  236,  237,  405, 1016, 1017,
  403,  995,  996,   54,  434,  435,  436,  437,  438,  439,
  440,  441,  730, 1214, 1215,  727, 1208, 1209,   93,   94,
   95,   96,   97,   98,   99,  100,  101,  102,  103,  104,
  105,  106,  107,  108,  109,  110,  111,  288,  289,  290,
  291,  292,  293,  294,  295,  296,
};
const short yysindex[] = {                                      0,
  679,  -30,  -99,  -93,    0,    0,    0,  -83,    0,  -71,
    0,    0,    0,    0,  -63,  -54,    0,    0,  -17,   -4,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -246,  527, -304, -297,   -3,
 -236,   -2,  273,    6,    9,   29,   30,  237, -235, -278,
   39,  130,  142,   47,   49,   90,   94,  105,  119, -110,
    0,    0,    0,    0,    0,  122,  124,  125,  126,  127,
  132,  136,  140,  144,  146,  149,  152,  153,  155,  157,
  161,  165,  162,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  106,    0,    0,  108,    0, -234,    0,  171,
 -114,    0,    0, -248,    0,  172,  173,  174,  178,  180,
  182,  185,  211,  214,  220,  221,  223,  224,  225,  228,
  232,  234,  236,  238,  242,  247,  248,  249,  251,  256,
  260,  261,  272,  276,  278,  280,  284,  285,    0,  287,
    0,  289,  290,  291,  292,  293,  297,  298,  302,  304,
  305,  307,  309,  311,  312,  313,  314,  315,  322,  327,
 -122,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, -220,  648, -238,
 -240,  334,  335,  336,  338,  339,  340,  341,  344,  345,
  349,  352,  353,  354,  -58,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  358,  359,
  360,  -97,    0,    0,    0,    0,  296,    0, -222,    0,
  361,  366,  367,  373,  376,  380,  381,  512,    0,    0,
    0,    0,    0,    0,    0,    0,  384,  383,  385,  386,
  387,  388,  391,  392,  394,  395,  397,  398,  -74,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -229, -231,    0,   51,   53,   58,  409,    0,   20,
   83,   84,   24,   91,   91,   92,   93,   25,   28,   95,
   91,   35,   37,   38,   40,   42,  424,    0,  709,  420,
    0,  431,  437, -121,    0,    0,    0,   98,  442,    0,
    0,  441,  443,    0, -113,    0,    0,    0,    0,   60,
   91,   61,   91,  129,  102,  138,   63,   68,   70,  139,
  118,   79,  147,  150,  151,  107,   91,  109,  115,  154,
  131,  137,  156,  170,   91,  187,  188,  133,  193,  210,
  158,  163,  472,  164,  506,   91,   91,  168,   91,  191,
  169,  175, -361, -353,  179,  181,   91,   91,  215,   91,
  183,  186,  189,  192,  542,    0,    0,    0,  543,  545,
    0,  550,  560,  -62,    0,    0,    0,    0,    0,    0,
    0,  568,  573,  575,  588,  590,    0,  591,  592,  594,
  595,  597,  598,  599,  600,  604,  606,  611,   87,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  618,    0,  620,
 -120,    0,    0,    0,    0,  570,    0,  621,  622,  624,
 -102,    0,    0,    0,    0,    0,    0,  245,  277,  279,
  281,  282,  283,  286,  288,  117,  294,  295,  244,  628,
    0,    0,  300,  306,  637,    0,  414,  639,  641,  650,
  652, -119,    0,    0,    0,    0,  267,  275,  301,  320,
  303,  308,   91,  671,    0,    0,  323,  310,  326,  329,
  330,  333,  342,  346,  356,  362,  369,  672,    0,  677,
  683,    0,  686, -106,    0,    0,    0,    0,  690,  692,
    0, -108,    0,    0,    0,  695,  704,  706,    0,  708,
  710,  716,  717, -313,  720,  725,  727,  729,  730,  732,
  733,  734,  740,  742,  743,  748,  749,    0,  750,  701,
  736,  752,  753,  757,  758,  759,  762,  763,  765,  766,
  769,  774,  219,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  778,  777,  779,
  780,  783,  785,  788,  792,  793,  794,    0,  795,  796,
  801,  802,  803,  804,  805,  808,  100,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  402,  430,  814,    0,
  815,    0,  467,  471,  820,  823,    0,  824,  825,  826,
  827,  828,  832,  833,  838,  839,  840,  842,  843,  844,
  846,  848,  854,  857,  858,  859,  860,  861,  864,  865,
  870,  871,  872,  873,  877,  880,  882,  883,  884,  885,
  668,  886,  703,  888,  889,  894,  898,  902,  905,  907,
  908,  909,  913,  915,  917,  919,  920,  922, -226,  923,
  924,  929,  930,  931,  932,    0,  934,   91,  552,  938,
  583,  596,  943,    0,    0,  554,  601,  555,  557,  947,
  563,  566,  567,  569,  574,  617,  644,  625,  627,  589,
  630,  950,    0,  631,  980,  633,  984,    0,    0,  983,
  636,  638,  659,  990,    0,  991,  993,  994,  996,  997,
  998,  999, 1000, 1004, 1005, 1006, 1007, 1008, 1009, 1010,
 1011, 1016, 1017,    0, 1019, 1020,    0, 1021, 1022, 1023,
 1025, 1032,    0, 1033, 1034, 1035, 1036, 1040, 1041, 1043,
 1044, 1045, 1046, 1047, 1048, 1049,    0, 1050, 1053, 1058,
    8,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  711,  712,  713, 1064,    0,
 1069, 1072, 1076, 1077, 1079, 1080, 1082,    0, 1083, 1084,
 1085, 1086, 1094, 1095, 1097, 1098, 1104, 1107, 1111,    0,
    0,  764, 1110,  767, 1115,    0,    0,  768, 1114, 1119,
    0,    0,    0,    0,    0,    0,    0,    0,   91,   91,
   91,   91,   91,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  811,
  818,   91,  819,  821,  822,  829,  770,  836,  837,   91,
   91,  215, 1121,    0,    0,  772, -368,  739,  782,  806,
  761,  781,  784,  817, 1128,  830,  831,  834,  835,  845,
  841,  847,  849, 1133,    0, 1142, 1152,    0,    0, 1153,
 1154,  800,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -18,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -13,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  215,  215,  215,    0,    0,    0,    0,    0,
    0,    0,    0, -256, 1168, 1170, -251, 1172, 1175,    0,
 1176, 1177, 1178, 1179,  855, 1183, 1186, 1187, 1188, 1189,
 1190, 1192, 1193, 1194, 1195, 1196,    0, 1198,  850, 1200,
    0, -318, 1201, 1202,  809,  -12,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  813,
  856,  851,  852, 1205,  853,  862,  863,  866,  867,  868,
  869,  874,  875,  876,  878,  879,  881, 1206,  887,  890,
  891, 1209,    0, 1210, 1211, 1212,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, 1213,  525, 1214,    0, 1215,
  593,    0,    0,    0,    0,    0,    0, 1216, 1217, 1219,
 1220, 1221, 1222, 1223, 1225, 1226, 1227, 1228, 1230, 1231,
    0, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1244,
 1245,  921, 1246, 1247, 1249, 1250, 1251, 1254, 1255, 1258,
    0,    0,    0,    0,    0,    0,  -11,    0,    0,  668,
    0,  703,    0,    0,    0,    0,    0,   -9,    0,    0,
    0,    0,    0,    5,    0,    0,    0,    0,    0,    0,
    0,    0,   12,    0,  529,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   18,    0,
    0,    0,    0,   21,    0,    0,    0,  933,    0,  659,
 1260, 1262, 1263, 1264,  940, 1269, 1270, 1272, 1273, 1274,
 1275, 1276, 1278, 1279, 1280, 1282, 1283, 1284,  738, 1285,
 1286, 1287,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   22,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   26,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   32,
    0, -174,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  800,    0,    0,    0, -256,    0, -251,  529,    0,
  855,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  850,    0, -318,    0,    0,    0,    0,
    0,    0,    0,   34,    0,  453,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   43,    0,    0,
    0,    0,    0,  525,    0,  593, -174,    0,  921,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  453,    0,  940,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  738,    0,    0,    0,    0,    0,
    0,    0,
};
const short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 1224, 1229,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, 1240,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 1289,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 1290,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 1289, 1289,
 1289, 1289, 1289,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1290, 1290, 1290,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  586,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   50,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -163,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  478,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  586,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, -163,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  478,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
const short yygindex[] = {                                      0,
 -334, -756, -417, -976,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, 1078,    0,    0,    0,
 1042,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 1288,    0,    0,    0,    0, 1099,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  544,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  -98,    0,    0,  -80,  -81,    0,    0,    0,    0,    0,
    0,  756,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   -6,  892,    0,    0,    0,    0,  111,    0,    0,  903,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   13,   16,
    0,    0,    0,    0,  893,    0,    0,    0,    0,    0,
  812,    0,    0,    0,    0,    0,  -47,    0,    0,  807,
    0,    0,    0,    0,  -48,    0,    0,    0,    0,  735,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  -49,  -46,    0,    0,    0,    0,    0,    0,    0,   10,
  895,    0,    0,    0,    0, 1024,    0,    0,    0, 1252,
    0,    0,    0,    0,    0,    0,   33, 1012,    0,    0,
    0, 1199,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  177,
    0,    0,  184,    0,    0,  948,    0,    0,    0,    0,
    0,    0,    0,    0,   41,    0,    0,   44,    0, 1292,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 1093,    0,
    0,    0,    0,    0,    0,    0,
};
#define YYTABLESIZE 1415
const short yytable[] = {                                     575,
  576,  720,  425,  659,  757,  839,  582,  361, 1206,   66,
  359,  666, 1242, 1212,  328,  486,  870,  477,  865,  119,
  269,  351,  764,   46,  559, 1200,  550,  515,   44,   47,
 1202, 1250, 1342,  518, 1346,  427,  669,  428,  671,   51,
 1199, 1033, 1034, 1035,   67, 1201, 1249, 1341, 1348, 1345,
  548,   53,  685,  519,   68, 1351, 1203, 1204, 1205,   58,
  693, 1364,  733, 1347, 1366, 1414,  510,  487,   59, 1416,
 1350,  704,  705,  574,  707, 1419, 1363, 1436,  429, 1365,
 1413,  430,  717,  718, 1415,  721, 1455,  711,  712, 1420,
 1418, 1421, 1435,  265,   45,  713,  714,  488, 1173, 1174,
  423, 1454,  423,  489,  112,   62, 1422,  120,  265,  352,
 1423,  115,  879,  880,  881,  882,  883,  423,   63,  118,
  124,  423, 1153, 1154, 1155, 1156, 1157,  362,  238,   69,
  276,  239, 1122,  125,  351,  477,  518,  431,  270,  126,
  127,  119,  361,  128,  560,   66,  551,  559,  324,  550,
  129,  240,  241,  486,  325,  432,  519,  520,  269,  130,
  719,  279,  363,  131,  132,  326, 1243,  490,  271,  322,
  133,  323,  478,  134,  135,  136,  353,  137, 1424,  327,
   67,  297,  330,  138,  331,  332,  333,  334,  521,  423,
   68,  364,  335,  427, 1207,  428,  336,  242,  847, 1213,
  337,  479,  139,  140,  338,  487,  339,  141,  561,  340,
  552,  752,  341,  342,  142,  343,  298,  344,  143,  144,
  145,  345,  352,  146,  934,  346,  147,  148,  349,  120,
  350,  358,  370,  371,  372,  488,  429,  149,  373,  430,
  374,  489,  375,  150,  151,  376,  152,  153,  154,  155,
  156,  243,  244,  245,  246,  247,  248,  249,  250,  480,
  520,  157,  362,  788,  299,   69,  789,  560,  553,  551,
  158,  377,  159,  160,  378,  161,  270,  433,  162,  163,
  379,  380,  164,  381,  382,  383,  347,  790,  384,  353,
  478,  521,  385,  165,  386,  431,  387,  363,  388,  791,
  251,  300,  389,  301,  302,  490,  271,  390,  391,  392,
  792,  393,  166,  432,  167,  793,  394, 1425,  168,  479,
  395,  396,  169,  170,  171,  172,  364,  794,  423,  173,
  174,  561,  397,  552,  795,  252,  398,  175,  399,  796,
  400,  797,  442,  913,  401,  402,  303,  404,  304,  406,
  407,  408,  409,  410,  798,  618,  619,  411,  412,  620,
  443,  305,  413,  621,  414,  415,  444,  416,  176,  417,
  177,  418,  419,  420,  421,  422,  178,  480,  622,  623,
  624,  179,  423,  799,  625,  280,  180,  424,  800,  445,
  446,  553,  497, 1045,  447,  498,  499,  297,  500,  501,
  502,  503,  626,  306,  504,  505,  627,  628,  448,  506,
  801,  253,  507,  508,  509,  449,  512,   75,  517,  513,
  514,  527,  802,  281,  803,  804,  528,  529,   76,  805,
  307,  308,  298,  530,  450,  433,  531,  629,  282,  630,
  532,  533,  536,  537,  254,  538,  539,  540,  541,   77,
   78,  542,  543,  631,  544,  545,   79,  546,  547,  566,
  283,  567,  284,  451,  285,  286,  568,  569,  570,  571,
  572,  452,  573,  579,  589,  632,  580,  574,  577,  578,
  299,  581,  588,  583,  287,  584,  585,  806,  586,  453,
  587,  657,  242,  807, 1170,  590,  591,  658,  454,  455,
  662,  663,  592,  664,  808,  809,  661,  633,  668,  670,
  673,  675,   80,   81,  810,  672,  676,  300,  677,  301,
  302,  634,   82,   83,  674,  678,  679,  680,  125,  456,
  457,  635,  701,  681,  126,  127,  682,  683,  128,  689,
  688,  696,  691,   84,   85,  129,  243,  244,  245,  246,
  247,  248,  249,  250,  130,  684,  692,  686,  131,  132,
   86,   87,  303,  687,  304,  133,  703, 1160,  134,  135,
  136,   88,  137,  694,  695, 1168, 1169,  305,  138,  697,
   89,  593,  594,  595,  458,  690,  596,  774,  775,  776,
  777,  778,  779,  780,  597,  251,  698,  139,  140,  708,
  726,  719,  141,  728,  636,  729,  699,  598,  599,  142,
  731,  700,  702,  143,  144,  145,  706,  709,  146,  306,
  732,  147,  148,  710,  600,  601,  735,  715,  759,  716,
  252,  722,  149,  736,  723,  737,  534,  724,  150,  151,
  725,  152,  153,  154,  155,  156,  307,  308,  738,  602,
  739,  741,  742,  766,  743,  744,  157,  745,  746,  747,
  748,   90,   91,   92,  749,  158,  750,  159,  160,  788,
  161,  751,  789,  162,  163,  618,  619,  164,  754,  620,
  756,  761,  762,  621,  763,  767,  784,  768,  165,  769,
  770,  771,  783,  790,  772,  787,  773,  835,  622,  623,
  624,  836,  781,  782,  625,  791,  253,  166,  785,  167,
  837, 1437,  838,  168,  786,  841,  792,  169,  170,  171,
  172,  793,  626,  842,  173,  174,  627,  628,  844,  848,
  860,  849,  175,  794,  851,  861,  195,  852,  853,  254,
  795,  854,  857,  862, 1438,  796,  864,  797,  867,  843,
  855,  845,  868,  872,  856, 1439,  846,  629,  850,  630,
  798,  900,  873,  176,  874,  177,  875,  280,  876,  195,
  858,  178, 1440,  631,  877,  878,  179,  859,  886, 1441,
  195,  180,   75,  887, 1442,  888, 1443,  889,  890,  799,
  891,  892,  893,   76,  800,  632,  901,  195,  894, 1444,
  895,  896, 1352, 1353,  195,  281,  897,  898,  899,  195,
  936,  195,  902,  903,   77,   78,  801,  904,  905,  906,
  282,   79,  907,  908,  195,  909,  910,  633,  802,  911,
  803,  804, 1354, 1445,  912,  805,  915,  916,  937,  917,
  918,  634,  283,  919,  284,  920,  285,  286,  921, 1446,
 1355,  635,  922,  923,  924,  926,  927, 1356,  195,  301,
  301,  928,  929,  930,  931,  932,  287, 1447,  933, 1448,
 1449, 1278,  938,  939,  195,  940, 1357,   80,   81,  941,
  942,  943,  944,  945,  946,  947,  948,   82,   83,  301,
  949,  950,  195,  806,  195,  195,  951,  952,  953,  807,
  954,  955,  956,  442,  957, 1358,  958,  301,   84,   85,
  808,  809,  959, 1359,  301,  960,  961,  962,  963,  964,
  810,  443,  965,  966,  636,   86,   87,  444,  967,  968,
  969,  970, 1450,  301,    2,  971,   88,    3,  972, 1293,
  973,  974,  975,  976,  997,   89, 1018, 1019, 1279, 1451,
  445,  446, 1020, 1360,    4,  447, 1021,  195,    5, 1452,
 1022,    6,  301, 1023,  589, 1024, 1025, 1026,    7,  448,
  301, 1027, 1361, 1028,  195, 1029,  449, 1030, 1031, 1280,
 1032, 1038, 1039,    8,  195,  590,  591, 1040, 1041, 1042,
 1043, 1048,  592, 1281, 1044,  450,    9,   10, 1047,   11,
 1046, 1050, 1051, 1053, 1049, 1054,   12, 1055, 1067, 1052,
  301, 1056, 1282, 1283, 1057, 1058, 1294, 1059, 1284, 1285,
 1286, 1287, 1060,   13,  451, 1061,   90,   91,   92,  301,
 1062, 1288,  452, 1063,   14, 1064,   15, 1065, 1066, 1068,
 1069, 1070, 1071, 1072, 1073, 1075, 1074, 1295, 1078, 1079,
  453, 1080, 1081,   16, 1082, 1083, 1084, 1085, 1086,  454,
  455, 1296, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094,
   17,  593,  594,  595, 1095, 1096,  596, 1097, 1098, 1099,
 1297, 1298, 1100, 1101,  597, 1102, 1299, 1300, 1301, 1302,
  456,  457, 1103, 1105, 1106, 1107, 1108,  598,  599, 1303,
 1109, 1110,   18, 1111, 1112, 1113, 1114, 1115, 1116, 1117,
 1119,   19,   20, 1120,  600,  601,   21,   22, 1121, 1124,
 1125, 1126, 1127,  977,  978,  979,  980, 1128,  981,  982,
 1129,  983,  984,  985, 1130, 1131,  986, 1132, 1133,  602,
 1134, 1135, 1136, 1137, 1138,  458,  987,  988,  989,  990,
  991,  992, 1139, 1140,  993, 1141, 1142,  994,  998,  999,
 1000, 1001, 1143, 1002, 1003, 1144, 1004, 1005, 1006, 1145,
 1147, 1007, 1146, 1149, 1151, 1148, 1150, 1152, 1165, 1171,
 1172, 1008, 1009, 1010, 1011, 1012, 1013, 1175, 1182, 1014,
 1176, 1191, 1015, 1390, 1391, 1392, 1393, 1158, 1394, 1395,
 1192, 1396, 1397, 1398, 1159, 1161, 1399, 1162, 1163, 1178,
 1193, 1194, 1195, 1196, 1177, 1164, 1400, 1401, 1402, 1403,
 1404, 1405, 1166, 1167, 1406, 1181, 1210, 1407, 1211, 1179,
 1216, 1187, 1180, 1217, 1218, 1219, 1220, 1221, 1183, 1184,
 1222, 1226, 1185, 1186, 1227, 1228, 1229, 1230, 1231, 1188,
 1232, 1233, 1234, 1235, 1236, 1189, 1237, 1190, 1241, 1246,
 1247, 1251, 1248, 1238, 1252, 1255, 1269, 1273, 1274, 1275,
 1276, 1277, 1291, 1292, 1306, 1307, 1261, 1308, 1309, 1310,
 1311, 1312, 1263, 1313, 1314, 1315, 1316, 1267, 1317, 1318,
 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1271, 1253,
 1254, 1256, 1327, 1328, 1333, 1334, 1329, 1335, 1336, 1337,
 1257, 1258, 1338, 1339, 1259, 1260, 1340, 1262, 1369, 1367,
 1370, 1371, 1372, 1264, 1265, 1373, 1266, 1377, 1378, 1268,
 1379, 1380, 1381, 1382, 1383, 1270, 1384, 1385, 1386, 1272,
 1387, 1388, 1389, 1410, 1411, 1412,  215,   25,   33,  516,
  549,  384, 1460,  511, 1123, 1461, 1462,  329,  914, 1433,
 1368,  753,  119, 1431, 1430,  866, 1456, 1457,  871, 1459,
 1458,  935,  360, 1432, 1427,  758,  667,  660, 1344,  426,
  535,  734,  765, 1343,  348,    0,    0,    0, 1429, 1428,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  840,
};
const short yycheck[] = {                                     334,
  335,  419,  125,  125,  125,  125,  341,  256,  265,  256,
  125,  125,  331,  265,  125,  256,  125,  256,  125,  256,
  256,  256,  125,  123,  256,   44,  256,  125,   59,  123,
   44,   44,   44,  256,   44,  256,  371,  258,  373,  123,
   59,  268,  269,  270,  291,   59,   59,   59,   44,   59,
  125,  123,  387,  276,  301,   44, 1033, 1034, 1035,  123,
  395,   44,  125,   59,   44,   44,  125,  308,  123,   44,
   59,  406,  407,  387,  409,   44,   59,   44,  299,   59,
   59,  302,  417,  418,   59,  420,   44,  449,  450,  264,
   59,  266,   59,   44,  125,  449,  450,  338,  467,  468,
  264,   59,  266,  344,  409,  123,  281,  344,   59,  344,
  285,  409,  426,  427,  428,  429,  430,  281,  123,  123,
  123,  285,  879,  880,  881,  882,  883,  376,  123,  376,
  409,  123,  125,  256,  256,  256,  256,  358,  374,  262,
  263,  256,  256,  266,  376,  256,  376,  256,   59,  256,
  273,  123,  123,  256,   61,  376,  276,  380,  256,  282,
  387,  123,  411,  286,  287,   61,  485,  408,  404,  123,
  293,  123,  411,  296,  297,  298,  411,  300,  353,   61,
  291,  256,   61,  306,   61,   61,   61,   61,  411,  353,
  301,  440,   61,  256,  451,  258,   61,  256,  533,  451,
   61,  440,  325,  326,   61,  308,   61,  330,  440,   61,
  440,  125,   61,   61,  337,   61,  291,   61,  341,  342,
  343,   61,  344,  346,  125,   61,  349,  350,  123,  344,
  123,   61,   61,   61,   61,  338,  299,  360,   61,  302,
   61,  344,   61,  366,  367,   61,  369,  370,  371,  372,
  373,  310,  311,  312,  313,  314,  315,  316,  317,  498,
  380,  384,  376,  256,  339,  376,  259,  376,  498,  376,
  393,   61,  395,  396,   61,  398,  374,  498,  401,  402,
   61,   61,  405,   61,   61,   61,  125,  280,   61,  411,
  411,  411,   61,  416,   61,  358,   61,  411,   61,  292,
  359,  376,   61,  378,  379,  408,  404,   61,   61,   61,
  303,   61,  435,  376,  437,  308,   61,  492,  441,  440,
   61,   61,  445,  446,  447,  448,  440,  320,  492,  452,
  453,  440,   61,  440,  327,  394,   61,  460,   61,  332,
   61,  334,  256,  125,   61,   61,  421,   61,  423,   61,
   61,   61,   61,   61,  347,  256,  257,   61,   61,  260,
  274,  436,   61,  264,   61,   61,  280,   61,  491,   61,
  493,   61,   61,   61,   61,   61,  499,  498,  279,  280,
  281,  504,   61,  376,  285,  256,  509,   61,  381,  303,
  304,  498,   59,  728,  308,   61,   61,  256,   61,   61,
   61,   61,  303,  478,   61,   61,  307,  308,  322,   61,
  403,  470,   61,   61,   61,  329,   59,  256,  123,   61,
   61,   61,  415,  294,  417,  418,   61,   61,  267,  422,
  505,  506,  291,   61,  348,  498,   61,  338,  309,  340,
   61,   61,   59,   61,  503,   61,   61,   61,   61,  288,
  289,   61,   61,  354,   61,   61,  295,   61,   61,  409,
  331,  409,  333,  377,  335,  336,  409,   59,  449,  387,
  387,  385,  449,  449,  256,  376,  449,  387,  387,  387,
  339,  387,   59,  449,  355,  449,  449,  480,  449,  403,
  449,   61,  256,  486,  912,  277,  278,   61,  412,  413,
   59,   61,  284,   61,  497,  498,  409,  408,  449,  449,
  409,  449,  351,  352,  507,  387,  449,  376,  449,  378,
  379,  422,  361,  362,  387,  387,  409,  449,  256,  443,
  444,  432,   61,  387,  262,  263,  387,  387,  266,  409,
  387,  409,  387,  382,  383,  273,  310,  311,  312,  313,
  314,  315,  316,  317,  282,  449,  387,  449,  286,  287,
  399,  400,  421,  449,  423,  293,   61,  902,  296,  297,
  298,  410,  300,  387,  387,  910,  911,  436,  306,  387,
  419,  363,  364,  365,  498,  449,  368,  471,  472,  473,
  474,  475,  476,  477,  376,  359,  387,  325,  326,  409,
   59,  387,  330,   61,  505,   61,  449,  389,  390,  337,
   61,  449,  449,  341,  342,  343,  449,  449,  346,  478,
   61,  349,  350,  449,  406,  407,   59,  449,   59,  449,
  394,  449,  360,   61,  449,   61,  125,  449,  366,  367,
  449,  369,  370,  371,  372,  373,  505,  506,   61,  431,
   61,   61,   61,  409,   61,   61,  384,   61,   61,   61,
   61,  500,  501,  502,   61,  393,   61,  395,  396,  256,
  398,   61,  259,  401,  402,  256,  257,  405,   61,  260,
   61,   61,   61,  264,   61,  409,   59,  409,  416,  409,
  409,  409,  449,  280,  409,   59,  409,   59,  279,  280,
  281,   61,  409,  409,  285,  292,  470,  435,  409,  437,
   61,  259,   61,  441,  409,  449,  303,  445,  446,  447,
  448,  308,  303,  449,  452,  453,  307,  308,  409,   59,
   59,  409,  460,  320,  409,   59,  259,  409,  409,  503,
  327,  409,  387,   61,  292,  332,   61,  334,   59,  449,
  409,  449,   61,   59,  409,  303,  449,  338,  449,  340,
  347,   61,   59,  491,   59,  493,   59,  256,   59,  292,
  409,  499,  320,  354,   59,   59,  504,  409,   59,  327,
  303,  509,  256,   59,  332,   59,  334,   59,   59,  376,
   59,   59,   59,  267,  381,  376,   61,  320,   59,  347,
   59,   59,  274,  275,  327,  294,   59,   59,   59,  332,
  409,  334,   61,   61,  288,  289,  403,   61,   61,   61,
  309,  295,   61,   61,  347,   61,   61,  408,  415,   61,
  417,  418,  304,  381,   61,  422,   59,   61,  409,   61,
   61,  422,  331,   61,  333,   61,  335,  336,   61,  397,
  322,  432,   61,   61,   61,   61,   61,  329,  381,  274,
  275,   61,   61,   61,   61,   61,  355,  415,   61,  417,
  418,  347,   59,   59,  397,  409,  348,  351,  352,  409,
   61,   59,   59,   59,   59,   59,   59,  361,  362,  304,
   59,   59,  415,  480,  417,  418,   59,   59,   59,  486,
   59,   59,   59,  256,   59,  377,   59,  322,  382,  383,
  497,  498,   59,  385,  329,   59,   59,   59,   59,   59,
  507,  274,   59,   59,  505,  399,  400,  280,   59,   59,
   59,   59,  480,  348,  256,   59,  410,  259,   59,  347,
   59,   59,   59,   59,   59,  419,   59,   59,  424,  497,
  303,  304,   59,  425,  276,  308,   59,  480,  280,  507,
   59,  283,  377,   59,  256,   59,   59,   59,  290,  322,
  385,   59,  444,   59,  497,   59,  329,   59,   59,  455,
   59,   59,   59,  305,  507,  277,  278,   59,   59,   59,
   59,  409,  284,  469,   61,  348,  318,  319,   61,  321,
  449,   59,  449,  449,  409,  449,  328,   61,   59,  409,
  425,  449,  488,  489,  449,  449,  424,  449,  494,  495,
  496,  497,  449,  345,  377,  409,  500,  501,  502,  444,
  387,  507,  385,  409,  356,  409,  358,  449,  409,  409,
   61,  409,   59,   61,  409,  387,  409,  455,   59,   59,
  403,   59,   59,  375,   59,   59,   59,   59,   59,  412,
  413,  469,   59,   59,   59,   59,   59,   59,   59,   59,
  392,  363,  364,  365,   59,   59,  368,   59,   59,   59,
  488,  489,   61,   61,  376,   61,  494,  495,  496,  497,
  443,  444,   61,   61,   61,   61,   61,  389,  390,  507,
   61,   61,  424,   61,   61,   61,   61,   61,   61,   61,
   61,  433,  434,   61,  406,  407,  438,  439,   61,  409,
  409,  409,   59,  456,  457,  458,  459,   59,  461,  462,
   59,  464,  465,  466,   59,   59,  469,   59,   59,  431,
   59,   59,   59,   59,   59,  498,  479,  480,  481,  482,
  483,  484,   59,   59,  487,   59,   59,  490,  456,  457,
  458,  459,   59,  461,  462,   59,  464,  465,  466,   59,
   61,  469,  409,   59,   61,  409,  409,   59,  409,   59,
  409,  479,  480,  481,  482,  483,  484,  449,   61,  487,
  409,   59,  490,  456,  457,  458,  459,  387,  461,  462,
   59,  464,  465,  466,  387,  387,  469,  387,  387,  449,
   59,   59,   59,  414,  409,  387,  479,  480,  481,  482,
  483,  484,  387,  387,  487,  409,   59,  490,   59,  449,
   59,  387,  449,   59,   59,   59,   59,   59,  409,  409,
  386,   59,  409,  409,   59,   59,   59,   59,   59,  409,
   59,   59,   59,   59,   59,  409,   59,  409,   59,   59,
   59,  449,  454,  414,  409,   61,   61,   59,   59,   59,
   59,   59,   59,   59,   59,   59,  409,   59,   59,   59,
   59,   59,  409,   59,   59,   59,   59,  409,   59,   59,
   59,   59,   59,   59,   59,   59,   59,   59,  409,  449,
  449,  449,   59,   59,   59,   59,  386,   59,   59,   59,
  449,  449,   59,   59,  449,  449,   59,  449,   59,  387,
   59,   59,   59,  449,  449,  386,  449,   59,   59,  449,
   59,   59,   59,   59,   59,  449,   59,   59,   59,  449,
   59,   59,   59,   59,   59,   59,  123,   59,   59,  272,
  309,  123, 1434,  255,  811, 1436, 1455,   70,  603, 1366,
 1250,  459,  123, 1351, 1349,  554, 1414, 1416,  562, 1419,
 1417,  637,  121, 1364, 1342,  481,  365,  354, 1202,  181,
  288,  434,  491, 1200,   93,   -1,   -1,   -1, 1348, 1346,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  522,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 509
#if YYDEBUG
const char * const yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",0,"'='",0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"ACCEPT_PASSWORD","ACTION","ADMIN","AFTYPE","T_ALLOW","ANTI_NICK_FLOOD",
"ANTI_SPAM_EXIT_MESSAGE_TIME","AUTOCONN","T_BLOCK","BURST_AWAY",
"BURST_TOPICWHO","BYTES","KBYTES","MBYTES","GBYTES","TBYTES","CALLER_ID_WAIT",
"CAN_FLOOD","CAN_IDLE","CHANNEL","CIDR_BITLEN_IPV4","CIDR_BITLEN_IPV6",
"CIPHER_PREFERENCE","CLASS","COMPRESSED","COMPRESSION_LEVEL","CONNECT",
"CONNECTFREQ","CRYPTLINK","DEFAULT_CIPHER_PREFERENCE","DEFAULT_FLOODCOUNT",
"DEFAULT_SPLIT_SERVER_COUNT","DEFAULT_SPLIT_USER_COUNT","DENY","DESCRIPTION",
"DIE","DISABLE_AUTH","DISABLE_HIDDEN","DISABLE_LOCAL_CHANNELS",
"DISABLE_REMOTE_COMMANDS","DOT_IN_IP6_ADDR","DOTS_IN_IDENT","DURATION",
"EGDPOOL_PATH","EMAIL","ENABLE","ENCRYPTED","EXCEED_LIMIT","EXEMPT",
"FAILED_OPER_NOTICE","FAKENAME","IRCD_FLAGS","FLATTEN_LINKS","FFAILED_OPERLOG",
"FKILLLOG","FKLINELOG","FGLINELOG","FIOERRLOG","FOPERLOG","FOPERSPYLOG",
"FUSERLOG","GECOS","GENERAL","GLINE","GLINES","GLINE_EXEMPT","GLINE_LOG",
"GLINE_TIME","GLINE_MIN_CIDR","GLINE_MIN_CIDR6","GLOBAL_KILL","IRCD_AUTH",
"NEED_IDENT","HAVENT_READ_CONF","HIDDEN","HIDDEN_ADMIN","HIDDEN_NAME",
"HIDDEN_OPER","HIDE_SERVER_IPS","HIDE_SERVERS","HIDE_SPOOF_IPS","HOST","HUB",
"HUB_MASK","IDLETIME","IGNORE_BOGUS_TS","INVISIBLE_ON_CONNECT","IP","KILL",
"KILL_CHASE_TIME_LIMIT","KLINE","KLINE_EXEMPT","KLINE_REASON",
"KLINE_WITH_REASON","KNOCK_DELAY","KNOCK_DELAY_CHANNEL","LAZYLINK","LEAF_MASK",
"LINKS_DELAY","LISTEN","T_LOG","LOGGING","LOG_LEVEL","MAX_ACCEPT","MAX_BANS",
"MAX_CHANS_PER_USER","MAX_GLOBAL","MAX_IDENT","MAX_LOCAL","MAX_NICK_CHANGES",
"MAX_NICK_TIME","MAX_NUMBER","MAX_TARGETS","MAX_WATCH","MESSAGE_LOCALE",
"MIN_NONWILDCARD","MIN_NONWILDCARD_SIMPLE","MODULE","MODULES","NAME",
"NEED_PASSWORD","NETWORK_DESC","NETWORK_NAME","NICK","NICK_CHANGES",
"NO_CREATE_ON_SPLIT","NO_JOIN_ON_SPLIT","NO_OPER_FLOOD","NO_TILDE","NOT",
"NUMBER","NUMBER_PER_IDENT","NUMBER_PER_CIDR","NUMBER_PER_IP",
"NUMBER_PER_IP_GLOBAL","OPERATOR","OPERS_BYPASS_CALLERID","OPER_LOG",
"OPER_ONLY_UMODES","OPER_PASS_RESV","OPER_SPY_T","OPER_UMODES",
"JOIN_FLOOD_COUNT","JOIN_FLOOD_TIME","PACE_WAIT","PACE_WAIT_SIMPLE","PASSWORD",
"PATH","PING_COOKIE","PING_TIME","PING_WARNING","PORT","QSTRING","QUIET_ON_BAN",
"REASON","REDIRPORT","REDIRSERV","REGEX_T","REHASH","TREJECT_HOLD_TIME",
"REMOTE","REMOTEBAN","RESTRICT_CHANNELS","RESTRICTED","RSA_PRIVATE_KEY_FILE",
"RSA_PUBLIC_KEY_FILE","SSL_CERTIFICATE_FILE","RESV","RESV_EXEMPT","SECONDS",
"MINUTES","HOURS","DAYS","WEEKS","SENDQ","SEND_PASSWORD","SERVERHIDE",
"SERVERINFO","SERVLINK_PATH","IRCD_SID","TKLINE_EXPIRE_NOTICES","T_SHARED",
"T_CLUSTER","TYPE","SHORT_MOTD","SILENT","SPOOF","SPOOF_NOTICE",
"STATS_I_OPER_ONLY","STATS_K_OPER_ONLY","STATS_O_OPER_ONLY","STATS_P_OPER_ONLY",
"TBOOL","TMASKED","T_REJECT","TS_MAX_DELTA","TS_WARN_DELTA","TWODOTS","T_ALL",
"T_BOTS","T_SOFTCALLERID","T_CALLERID","T_CCONN","T_CLIENT_FLOOD","T_DEAF",
"T_DEBUG","T_DRONE","T_EXTERNAL","T_FULL","T_INVISIBLE","T_IPV4","T_IPV6",
"T_LOCOPS","T_LOGPATH","T_L_CRIT","T_L_DEBUG","T_L_ERROR","T_L_INFO",
"T_L_NOTICE","T_L_TRACE","T_L_WARN","T_MAX_CLIENTS","T_NCHANGE","T_OPERWALL",
"T_REJ","T_SERVNOTICE","T_SKILL","T_SPY","T_SSL","T_UMODES","T_UNAUTH",
"T_UNRESV","T_UNXLINE","T_WALLOP","THROTTLE_TIME","TOPICBURST",
"TRUE_NO_OPER_FLOOD","TKLINE","TXLINE","TRESV","UNKLINE","USER","USE_EGD",
"USE_EXCEPT","USE_INVEX","USE_KNOCK","USE_LOGGING","USE_WHOIS_ACTUALLY","VHOST",
"VHOST6","XLINE","WARN","WARN_NO_NLINE",
};
const char * const yyrule[] = {
"$accept : conf",
"conf :",
"conf : conf conf_item",
"conf_item : admin_entry",
"conf_item : logging_entry",
"conf_item : oper_entry",
"conf_item : channel_entry",
"conf_item : class_entry",
"conf_item : listen_entry",
"conf_item : auth_entry",
"conf_item : serverinfo_entry",
"conf_item : serverhide_entry",
"conf_item : resv_entry",
"conf_item : shared_entry",
"conf_item : cluster_entry",
"conf_item : connect_entry",
"conf_item : kill_entry",
"conf_item : deny_entry",
"conf_item : exempt_entry",
"conf_item : general_entry",
"conf_item : gline_entry",
"conf_item : gecos_entry",
"conf_item : modules_entry",
"conf_item : error ';'",
"conf_item : error '}'",
"timespec_ :",
"timespec_ : timespec",
"timespec : NUMBER timespec_",
"timespec : NUMBER SECONDS timespec_",
"timespec : NUMBER MINUTES timespec_",
"timespec : NUMBER HOURS timespec_",
"timespec : NUMBER DAYS timespec_",
"timespec : NUMBER WEEKS timespec_",
"sizespec_ :",
"sizespec_ : sizespec",
"sizespec : NUMBER sizespec_",
"sizespec : NUMBER BYTES sizespec_",
"sizespec : NUMBER KBYTES sizespec_",
"sizespec : NUMBER MBYTES sizespec_",
"modules_entry : MODULES '{' modules_items '}' ';'",
"modules_items : modules_items modules_item",
"modules_items : modules_item",
"modules_item : modules_module",
"modules_item : modules_path",
"modules_item : error ';'",
"modules_module : MODULE '=' QSTRING ';'",
"modules_path : PATH '=' QSTRING ';'",
"serverinfo_entry : SERVERINFO '{' serverinfo_items '}' ';'",
"serverinfo_items : serverinfo_items serverinfo_item",
"serverinfo_items : serverinfo_item",
"serverinfo_item : serverinfo_name",
"serverinfo_item : serverinfo_vhost",
"serverinfo_item : serverinfo_hub",
"serverinfo_item : serverinfo_description",
"serverinfo_item : serverinfo_network_name",
"serverinfo_item : serverinfo_network_desc",
"serverinfo_item : serverinfo_max_clients",
"serverinfo_item : serverinfo_rsa_private_key_file",
"serverinfo_item : serverinfo_vhost6",
"serverinfo_item : serverinfo_sid",
"serverinfo_item : serverinfo_ssl_certificate_file",
"serverinfo_item : error ';'",
"serverinfo_ssl_certificate_file : SSL_CERTIFICATE_FILE '=' QSTRING ';'",
"serverinfo_rsa_private_key_file : RSA_PRIVATE_KEY_FILE '=' QSTRING ';'",
"serverinfo_name : NAME '=' QSTRING ';'",
"serverinfo_sid : IRCD_SID '=' QSTRING ';'",
"serverinfo_description : DESCRIPTION '=' QSTRING ';'",
"serverinfo_network_name : NETWORK_NAME '=' QSTRING ';'",
"serverinfo_network_desc : NETWORK_DESC '=' QSTRING ';'",
"serverinfo_vhost : VHOST '=' QSTRING ';'",
"serverinfo_vhost6 : VHOST6 '=' QSTRING ';'",
"serverinfo_max_clients : T_MAX_CLIENTS '=' NUMBER ';'",
"serverinfo_hub : HUB '=' TBOOL ';'",
"admin_entry : ADMIN '{' admin_items '}' ';'",
"admin_items : admin_items admin_item",
"admin_items : admin_item",
"admin_item : admin_name",
"admin_item : admin_description",
"admin_item : admin_email",
"admin_item : error ';'",
"admin_name : NAME '=' QSTRING ';'",
"admin_email : EMAIL '=' QSTRING ';'",
"admin_description : DESCRIPTION '=' QSTRING ';'",
"logging_entry : LOGGING '{' logging_items '}' ';'",
"logging_items : logging_items logging_item",
"logging_items : logging_item",
"logging_item : logging_path",
"logging_item : logging_oper_log",
"logging_item : logging_log_level",
"logging_item : logging_use_logging",
"logging_item : logging_fuserlog",
"logging_item : logging_foperlog",
"logging_item : logging_fglinelog",
"logging_item : logging_fklinelog",
"logging_item : logging_killlog",
"logging_item : logging_foperspylog",
"logging_item : logging_ioerrlog",
"logging_item : logging_ffailed_operlog",
"logging_item : error ';'",
"logging_path : T_LOGPATH '=' QSTRING ';'",
"logging_oper_log : OPER_LOG '=' QSTRING ';'",
"logging_fuserlog : FUSERLOG '=' QSTRING ';'",
"logging_ffailed_operlog : FFAILED_OPERLOG '=' QSTRING ';'",
"logging_foperlog : FOPERLOG '=' QSTRING ';'",
"logging_foperspylog : FOPERSPYLOG '=' QSTRING ';'",
"logging_fglinelog : FGLINELOG '=' QSTRING ';'",
"logging_fklinelog : FKLINELOG '=' QSTRING ';'",
"logging_ioerrlog : FIOERRLOG '=' QSTRING ';'",
"logging_killlog : FKILLLOG '=' QSTRING ';'",
"logging_log_level : LOG_LEVEL '=' T_L_CRIT ';'",
"logging_log_level : LOG_LEVEL '=' T_L_ERROR ';'",
"logging_log_level : LOG_LEVEL '=' T_L_WARN ';'",
"logging_log_level : LOG_LEVEL '=' T_L_NOTICE ';'",
"logging_log_level : LOG_LEVEL '=' T_L_TRACE ';'",
"logging_log_level : LOG_LEVEL '=' T_L_INFO ';'",
"logging_log_level : LOG_LEVEL '=' T_L_DEBUG ';'",
"logging_use_logging : USE_LOGGING '=' TBOOL ';'",
"$$1 :",
"oper_entry : OPERATOR $$1 oper_name_b '{' oper_items '}' ';'",
"oper_name_b :",
"oper_name_b : oper_name_t",
"oper_items : oper_items oper_item",
"oper_items : oper_item",
"oper_item : oper_name",
"oper_item : oper_user",
"oper_item : oper_password",
"oper_item : oper_hidden_admin",
"oper_item : oper_hidden_oper",
"oper_item : oper_umodes",
"oper_item : oper_class",
"oper_item : oper_global_kill",
"oper_item : oper_remote",
"oper_item : oper_kline",
"oper_item : oper_xline",
"oper_item : oper_unkline",
"oper_item : oper_gline",
"oper_item : oper_nick_changes",
"oper_item : oper_remoteban",
"oper_item : oper_die",
"oper_item : oper_rehash",
"oper_item : oper_admin",
"oper_item : oper_operwall",
"oper_item : oper_encrypted",
"oper_item : oper_rsa_public_key_file",
"oper_item : oper_flags",
"oper_item : error ';'",
"oper_name : NAME '=' QSTRING ';'",
"oper_name_t : QSTRING",
"oper_user : USER '=' QSTRING ';'",
"oper_password : PASSWORD '=' QSTRING ';'",
"oper_encrypted : ENCRYPTED '=' TBOOL ';'",
"oper_rsa_public_key_file : RSA_PUBLIC_KEY_FILE '=' QSTRING ';'",
"oper_class : CLASS '=' QSTRING ';'",
"$$2 :",
"oper_umodes : T_UMODES $$2 '=' oper_umodes_items ';'",
"oper_umodes_items : oper_umodes_items ',' oper_umodes_item",
"oper_umodes_items : oper_umodes_item",
"oper_umodes_item : T_BOTS",
"oper_umodes_item : T_CCONN",
"oper_umodes_item : T_DEAF",
"oper_umodes_item : T_DEBUG",
"oper_umodes_item : T_FULL",
"oper_umodes_item : T_SKILL",
"oper_umodes_item : T_NCHANGE",
"oper_umodes_item : T_REJ",
"oper_umodes_item : T_UNAUTH",
"oper_umodes_item : T_SPY",
"oper_umodes_item : T_EXTERNAL",
"oper_umodes_item : T_OPERWALL",
"oper_umodes_item : T_SERVNOTICE",
"oper_umodes_item : T_INVISIBLE",
"oper_umodes_item : T_WALLOP",
"oper_umodes_item : T_SOFTCALLERID",
"oper_umodes_item : T_CALLERID",
"oper_umodes_item : T_LOCOPS",
"oper_global_kill : GLOBAL_KILL '=' TBOOL ';'",
"oper_remote : REMOTE '=' TBOOL ';'",
"oper_remoteban : REMOTEBAN '=' TBOOL ';'",
"oper_kline : KLINE '=' TBOOL ';'",
"oper_xline : XLINE '=' TBOOL ';'",
"oper_unkline : UNKLINE '=' TBOOL ';'",
"oper_gline : GLINE '=' TBOOL ';'",
"oper_nick_changes : NICK_CHANGES '=' TBOOL ';'",
"oper_die : DIE '=' TBOOL ';'",
"oper_rehash : REHASH '=' TBOOL ';'",
"oper_admin : ADMIN '=' TBOOL ';'",
"oper_hidden_admin : HIDDEN_ADMIN '=' TBOOL ';'",
"oper_hidden_oper : HIDDEN_OPER '=' TBOOL ';'",
"oper_operwall : T_OPERWALL '=' TBOOL ';'",
"$$3 :",
"oper_flags : IRCD_FLAGS $$3 '=' oper_flags_items ';'",
"oper_flags_items : oper_flags_items ',' oper_flags_item",
"oper_flags_items : oper_flags_item",
"$$4 :",
"oper_flags_item : NOT $$4 oper_flags_item_atom",
"$$5 :",
"oper_flags_item : $$5 oper_flags_item_atom",
"oper_flags_item_atom : GLOBAL_KILL",
"oper_flags_item_atom : REMOTE",
"oper_flags_item_atom : KLINE",
"oper_flags_item_atom : UNKLINE",
"oper_flags_item_atom : XLINE",
"oper_flags_item_atom : GLINE",
"oper_flags_item_atom : DIE",
"oper_flags_item_atom : REHASH",
"oper_flags_item_atom : ADMIN",
"oper_flags_item_atom : HIDDEN_ADMIN",
"oper_flags_item_atom : NICK_CHANGES",
"oper_flags_item_atom : T_OPERWALL",
"oper_flags_item_atom : OPER_SPY_T",
"oper_flags_item_atom : HIDDEN_OPER",
"oper_flags_item_atom : REMOTEBAN",
"oper_flags_item_atom : ENCRYPTED",
"$$6 :",
"class_entry : CLASS $$6 class_name_b '{' class_items '}' ';'",
"class_name_b :",
"class_name_b : class_name_t",
"class_items : class_items class_item",
"class_items : class_item",
"class_item : class_name",
"class_item : class_cidr_bitlen_ipv4",
"class_item : class_cidr_bitlen_ipv6",
"class_item : class_ping_time",
"class_item : class_ping_warning",
"class_item : class_number_per_cidr",
"class_item : class_number_per_ip",
"class_item : class_connectfreq",
"class_item : class_max_number",
"class_item : class_max_global",
"class_item : class_max_local",
"class_item : class_max_ident",
"class_item : class_sendq",
"class_item : error ';'",
"class_name : NAME '=' QSTRING ';'",
"class_name_t : QSTRING",
"class_ping_time : PING_TIME '=' timespec ';'",
"class_ping_warning : PING_WARNING '=' timespec ';'",
"class_number_per_ip : NUMBER_PER_IP '=' NUMBER ';'",
"class_connectfreq : CONNECTFREQ '=' timespec ';'",
"class_max_number : MAX_NUMBER '=' NUMBER ';'",
"class_max_global : MAX_GLOBAL '=' NUMBER ';'",
"class_max_local : MAX_LOCAL '=' NUMBER ';'",
"class_max_ident : MAX_IDENT '=' NUMBER ';'",
"class_sendq : SENDQ '=' sizespec ';'",
"class_cidr_bitlen_ipv4 : CIDR_BITLEN_IPV4 '=' NUMBER ';'",
"class_cidr_bitlen_ipv6 : CIDR_BITLEN_IPV6 '=' NUMBER ';'",
"class_number_per_cidr : NUMBER_PER_CIDR '=' NUMBER ';'",
"$$7 :",
"listen_entry : LISTEN $$7 '{' listen_items '}' ';'",
"$$8 :",
"listen_flags : IRCD_FLAGS $$8 '=' listen_flags_items ';'",
"listen_flags_items : listen_flags_items ',' listen_flags_item",
"listen_flags_items : listen_flags_item",
"listen_flags_item : T_SSL",
"listen_flags_item : HIDDEN",
"listen_items : listen_items listen_item",
"listen_items : listen_item",
"listen_item : listen_port",
"listen_item : listen_flags",
"listen_item : listen_address",
"listen_item : listen_host",
"listen_item : error ';'",
"listen_port : PORT '=' port_items ';'",
"port_items : port_items ',' port_item",
"port_items : port_item",
"port_item : NUMBER",
"port_item : NUMBER TWODOTS NUMBER",
"listen_address : IP '=' QSTRING ';'",
"listen_host : HOST '=' QSTRING ';'",
"$$9 :",
"auth_entry : IRCD_AUTH $$9 '{' auth_items '}' ';'",
"auth_items : auth_items auth_item",
"auth_items : auth_item",
"auth_item : auth_user",
"auth_item : auth_passwd",
"auth_item : auth_class",
"auth_item : auth_flags",
"auth_item : auth_kline_exempt",
"auth_item : auth_need_ident",
"auth_item : auth_exceed_limit",
"auth_item : auth_no_tilde",
"auth_item : auth_gline_exempt",
"auth_item : auth_spoof",
"auth_item : auth_spoof_notice",
"auth_item : auth_redir_serv",
"auth_item : auth_redir_port",
"auth_item : auth_can_flood",
"auth_item : auth_need_password",
"auth_item : auth_encrypted",
"auth_item : error ';'",
"auth_user : USER '=' QSTRING ';'",
"auth_passwd : PASSWORD '=' QSTRING ';'",
"auth_spoof_notice : SPOOF_NOTICE '=' TBOOL ';'",
"auth_class : CLASS '=' QSTRING ';'",
"auth_encrypted : ENCRYPTED '=' TBOOL ';'",
"$$10 :",
"auth_flags : IRCD_FLAGS $$10 '=' auth_flags_items ';'",
"auth_flags_items : auth_flags_items ',' auth_flags_item",
"auth_flags_items : auth_flags_item",
"$$11 :",
"auth_flags_item : NOT $$11 auth_flags_item_atom",
"$$12 :",
"auth_flags_item : $$12 auth_flags_item_atom",
"auth_flags_item_atom : SPOOF_NOTICE",
"auth_flags_item_atom : EXCEED_LIMIT",
"auth_flags_item_atom : KLINE_EXEMPT",
"auth_flags_item_atom : NEED_IDENT",
"auth_flags_item_atom : CAN_FLOOD",
"auth_flags_item_atom : CAN_IDLE",
"auth_flags_item_atom : NO_TILDE",
"auth_flags_item_atom : GLINE_EXEMPT",
"auth_flags_item_atom : RESV_EXEMPT",
"auth_flags_item_atom : NEED_PASSWORD",
"auth_kline_exempt : KLINE_EXEMPT '=' TBOOL ';'",
"auth_need_ident : NEED_IDENT '=' TBOOL ';'",
"auth_exceed_limit : EXCEED_LIMIT '=' TBOOL ';'",
"auth_can_flood : CAN_FLOOD '=' TBOOL ';'",
"auth_no_tilde : NO_TILDE '=' TBOOL ';'",
"auth_gline_exempt : GLINE_EXEMPT '=' TBOOL ';'",
"auth_spoof : SPOOF '=' QSTRING ';'",
"auth_redir_serv : REDIRSERV '=' QSTRING ';'",
"auth_redir_port : REDIRPORT '=' NUMBER ';'",
"auth_need_password : NEED_PASSWORD '=' TBOOL ';'",
"$$13 :",
"resv_entry : RESV $$13 '{' resv_items '}' ';'",
"resv_items : resv_items resv_item",
"resv_items : resv_item",
"resv_item : resv_creason",
"resv_item : resv_channel",
"resv_item : resv_nick",
"resv_item : error ';'",
"resv_creason : REASON '=' QSTRING ';'",
"resv_channel : CHANNEL '=' QSTRING ';'",
"resv_nick : NICK '=' QSTRING ';'",
"$$14 :",
"shared_entry : T_SHARED $$14 '{' shared_items '}' ';'",
"shared_items : shared_items shared_item",
"shared_items : shared_item",
"shared_item : shared_name",
"shared_item : shared_user",
"shared_item : shared_type",
"shared_item : error ';'",
"shared_name : NAME '=' QSTRING ';'",
"shared_user : USER '=' QSTRING ';'",
"$$15 :",
"shared_type : TYPE $$15 '=' shared_types ';'",
"shared_types : shared_types ',' shared_type_item",
"shared_types : shared_type_item",
"shared_type_item : KLINE",
"shared_type_item : TKLINE",
"shared_type_item : UNKLINE",
"shared_type_item : XLINE",
"shared_type_item : TXLINE",
"shared_type_item : T_UNXLINE",
"shared_type_item : RESV",
"shared_type_item : TRESV",
"shared_type_item : T_UNRESV",
"shared_type_item : T_LOCOPS",
"shared_type_item : T_ALL",
"$$16 :",
"cluster_entry : T_CLUSTER $$16 '{' cluster_items '}' ';'",
"cluster_items : cluster_items cluster_item",
"cluster_items : cluster_item",
"cluster_item : cluster_name",
"cluster_item : cluster_type",
"cluster_item : error ';'",
"cluster_name : NAME '=' QSTRING ';'",
"$$17 :",
"cluster_type : TYPE $$17 '=' cluster_types ';'",
"cluster_types : cluster_types ',' cluster_type_item",
"cluster_types : cluster_type_item",
"cluster_type_item : KLINE",
"cluster_type_item : TKLINE",
"cluster_type_item : UNKLINE",
"cluster_type_item : XLINE",
"cluster_type_item : TXLINE",
"cluster_type_item : T_UNXLINE",
"cluster_type_item : RESV",
"cluster_type_item : TRESV",
"cluster_type_item : T_UNRESV",
"cluster_type_item : T_LOCOPS",
"cluster_type_item : T_ALL",
"$$18 :",
"connect_entry : CONNECT $$18 connect_name_b '{' connect_items '}' ';'",
"connect_name_b :",
"connect_name_b : connect_name_t",
"connect_items : connect_items connect_item",
"connect_items : connect_item",
"connect_item : connect_name",
"connect_item : connect_host",
"connect_item : connect_vhost",
"connect_item : connect_send_password",
"connect_item : connect_accept_password",
"connect_item : connect_aftype",
"connect_item : connect_port",
"connect_item : connect_fakename",
"connect_item : connect_flags",
"connect_item : connect_hub_mask",
"connect_item : connect_leaf_mask",
"connect_item : connect_class",
"connect_item : connect_auto",
"connect_item : connect_encrypted",
"connect_item : connect_compressed",
"connect_item : connect_cryptlink",
"connect_item : connect_rsa_public_key_file",
"connect_item : connect_cipher_preference",
"connect_item : error ';'",
"connect_name : NAME '=' QSTRING ';'",
"connect_name_t : QSTRING",
"connect_host : HOST '=' QSTRING ';'",
"connect_vhost : VHOST '=' QSTRING ';'",
"connect_send_password : SEND_PASSWORD '=' QSTRING ';'",
"connect_accept_password : ACCEPT_PASSWORD '=' QSTRING ';'",
"connect_port : PORT '=' NUMBER ';'",
"connect_aftype : AFTYPE '=' T_IPV4 ';'",
"connect_aftype : AFTYPE '=' T_IPV6 ';'",
"connect_fakename : FAKENAME '=' QSTRING ';'",
"$$19 :",
"connect_flags : IRCD_FLAGS $$19 '=' connect_flags_items ';'",
"connect_flags_items : connect_flags_items ',' connect_flags_item",
"connect_flags_items : connect_flags_item",
"$$20 :",
"connect_flags_item : NOT $$20 connect_flags_item_atom",
"$$21 :",
"connect_flags_item : $$21 connect_flags_item_atom",
"connect_flags_item_atom : LAZYLINK",
"connect_flags_item_atom : COMPRESSED",
"connect_flags_item_atom : CRYPTLINK",
"connect_flags_item_atom : AUTOCONN",
"connect_flags_item_atom : BURST_AWAY",
"connect_flags_item_atom : TOPICBURST",
"connect_rsa_public_key_file : RSA_PUBLIC_KEY_FILE '=' QSTRING ';'",
"connect_encrypted : ENCRYPTED '=' TBOOL ';'",
"connect_cryptlink : CRYPTLINK '=' TBOOL ';'",
"connect_compressed : COMPRESSED '=' TBOOL ';'",
"connect_auto : AUTOCONN '=' TBOOL ';'",
"connect_hub_mask : HUB_MASK '=' QSTRING ';'",
"connect_leaf_mask : LEAF_MASK '=' QSTRING ';'",
"connect_class : CLASS '=' QSTRING ';'",
"connect_cipher_preference : CIPHER_PREFERENCE '=' QSTRING ';'",
"$$22 :",
"kill_entry : KILL $$22 '{' kill_items '}' ';'",
"$$23 :",
"kill_type : TYPE $$23 '=' kill_type_items ';'",
"kill_type_items : kill_type_items ',' kill_type_item",
"kill_type_items : kill_type_item",
"kill_type_item : REGEX_T",
"kill_items : kill_items kill_item",
"kill_items : kill_item",
"kill_item : kill_user",
"kill_item : kill_reason",
"kill_item : kill_type",
"kill_item : error",
"kill_user : USER '=' QSTRING ';'",
"kill_reason : REASON '=' QSTRING ';'",
"$$24 :",
"deny_entry : DENY $$24 '{' deny_items '}' ';'",
"deny_items : deny_items deny_item",
"deny_items : deny_item",
"deny_item : deny_ip",
"deny_item : deny_reason",
"deny_item : error",
"deny_ip : IP '=' QSTRING ';'",
"deny_reason : REASON '=' QSTRING ';'",
"exempt_entry : EXEMPT '{' exempt_items '}' ';'",
"exempt_items : exempt_items exempt_item",
"exempt_items : exempt_item",
"exempt_item : exempt_ip",
"exempt_item : error",
"exempt_ip : IP '=' QSTRING ';'",
"$$25 :",
"gecos_entry : GECOS $$25 '{' gecos_items '}' ';'",
"$$26 :",
"gecos_flags : TYPE $$26 '=' gecos_flags_items ';'",
"gecos_flags_items : gecos_flags_items ',' gecos_flags_item",
"gecos_flags_items : gecos_flags_item",
"gecos_flags_item : REGEX_T",
"gecos_items : gecos_items gecos_item",
"gecos_items : gecos_item",
"gecos_item : gecos_name",
"gecos_item : gecos_reason",
"gecos_item : gecos_flags",
"gecos_item : error",
"gecos_name : NAME '=' QSTRING ';'",
"gecos_reason : REASON '=' QSTRING ';'",
"general_entry : GENERAL '{' general_items '}' ';'",
"general_items : general_items general_item",
"general_items : general_item",
"general_item : general_hide_spoof_ips",
"general_item : general_ignore_bogus_ts",
"general_item : general_failed_oper_notice",
"general_item : general_anti_nick_flood",
"general_item : general_max_nick_time",
"general_item : general_max_nick_changes",
"general_item : general_max_accept",
"general_item : general_anti_spam_exit_message_time",
"general_item : general_ts_warn_delta",
"general_item : general_ts_max_delta",
"general_item : general_kill_chase_time_limit",
"general_item : general_kline_with_reason",
"general_item : general_kline_reason",
"general_item : general_invisible_on_connect",
"general_item : general_warn_no_nline",
"general_item : general_dots_in_ident",
"general_item : general_stats_o_oper_only",
"general_item : general_stats_k_oper_only",
"general_item : general_pace_wait",
"general_item : general_stats_i_oper_only",
"general_item : general_pace_wait_simple",
"general_item : general_stats_P_oper_only",
"general_item : general_short_motd",
"general_item : general_no_oper_flood",
"general_item : general_true_no_oper_flood",
"general_item : general_oper_pass_resv",
"general_item : general_idletime",
"general_item : general_message_locale",
"general_item : general_oper_only_umodes",
"general_item : general_max_targets",
"general_item : general_use_egd",
"general_item : general_egdpool_path",
"general_item : general_oper_umodes",
"general_item : general_caller_id_wait",
"general_item : general_opers_bypass_callerid",
"general_item : general_default_floodcount",
"general_item : general_min_nonwildcard",
"general_item : general_min_nonwildcard_simple",
"general_item : general_servlink_path",
"general_item : general_disable_remote_commands",
"general_item : general_default_cipher_preference",
"general_item : general_compression_level",
"general_item : general_client_flood",
"general_item : general_throttle_time",
"general_item : general_havent_read_conf",
"general_item : general_dot_in_ip6_addr",
"general_item : general_ping_cookie",
"general_item : general_disable_auth",
"general_item : general_burst_away",
"general_item : general_tkline_expire_notices",
"general_item : general_gline_min_cidr",
"general_item : general_gline_min_cidr6",
"general_item : general_use_whois_actually",
"general_item : general_reject_hold_time",
"general_item : general_max_watch",
"general_item : error",
"general_max_watch : MAX_WATCH '=' NUMBER ';'",
"general_gline_min_cidr : GLINE_MIN_CIDR '=' NUMBER ';'",
"general_gline_min_cidr6 : GLINE_MIN_CIDR6 '=' NUMBER ';'",
"general_burst_away : BURST_AWAY '=' TBOOL ';'",
"general_use_whois_actually : USE_WHOIS_ACTUALLY '=' TBOOL ';'",
"general_reject_hold_time : TREJECT_HOLD_TIME '=' timespec ';'",
"general_tkline_expire_notices : TKLINE_EXPIRE_NOTICES '=' TBOOL ';'",
"general_kill_chase_time_limit : KILL_CHASE_TIME_LIMIT '=' NUMBER ';'",
"general_hide_spoof_ips : HIDE_SPOOF_IPS '=' TBOOL ';'",
"general_ignore_bogus_ts : IGNORE_BOGUS_TS '=' TBOOL ';'",
"general_disable_remote_commands : DISABLE_REMOTE_COMMANDS '=' TBOOL ';'",
"general_failed_oper_notice : FAILED_OPER_NOTICE '=' TBOOL ';'",
"general_anti_nick_flood : ANTI_NICK_FLOOD '=' TBOOL ';'",
"general_max_nick_time : MAX_NICK_TIME '=' timespec ';'",
"general_max_nick_changes : MAX_NICK_CHANGES '=' NUMBER ';'",
"general_max_accept : MAX_ACCEPT '=' NUMBER ';'",
"general_anti_spam_exit_message_time : ANTI_SPAM_EXIT_MESSAGE_TIME '=' timespec ';'",
"general_ts_warn_delta : TS_WARN_DELTA '=' timespec ';'",
"general_ts_max_delta : TS_MAX_DELTA '=' timespec ';'",
"general_havent_read_conf : HAVENT_READ_CONF '=' NUMBER ';'",
"general_kline_with_reason : KLINE_WITH_REASON '=' TBOOL ';'",
"general_kline_reason : KLINE_REASON '=' QSTRING ';'",
"general_invisible_on_connect : INVISIBLE_ON_CONNECT '=' TBOOL ';'",
"general_warn_no_nline : WARN_NO_NLINE '=' TBOOL ';'",
"general_stats_o_oper_only : STATS_O_OPER_ONLY '=' TBOOL ';'",
"general_stats_P_oper_only : STATS_P_OPER_ONLY '=' TBOOL ';'",
"general_stats_k_oper_only : STATS_K_OPER_ONLY '=' TBOOL ';'",
"general_stats_k_oper_only : STATS_K_OPER_ONLY '=' TMASKED ';'",
"general_stats_i_oper_only : STATS_I_OPER_ONLY '=' TBOOL ';'",
"general_stats_i_oper_only : STATS_I_OPER_ONLY '=' TMASKED ';'",
"general_pace_wait : PACE_WAIT '=' timespec ';'",
"general_caller_id_wait : CALLER_ID_WAIT '=' timespec ';'",
"general_opers_bypass_callerid : OPERS_BYPASS_CALLERID '=' TBOOL ';'",
"general_pace_wait_simple : PACE_WAIT_SIMPLE '=' timespec ';'",
"general_short_motd : SHORT_MOTD '=' TBOOL ';'",
"general_no_oper_flood : NO_OPER_FLOOD '=' TBOOL ';'",
"general_true_no_oper_flood : TRUE_NO_OPER_FLOOD '=' TBOOL ';'",
"general_oper_pass_resv : OPER_PASS_RESV '=' TBOOL ';'",
"general_message_locale : MESSAGE_LOCALE '=' QSTRING ';'",
"general_idletime : IDLETIME '=' timespec ';'",
"general_dots_in_ident : DOTS_IN_IDENT '=' NUMBER ';'",
"general_max_targets : MAX_TARGETS '=' NUMBER ';'",
"general_servlink_path : SERVLINK_PATH '=' QSTRING ';'",
"general_default_cipher_preference : DEFAULT_CIPHER_PREFERENCE '=' QSTRING ';'",
"general_compression_level : COMPRESSION_LEVEL '=' NUMBER ';'",
"general_use_egd : USE_EGD '=' TBOOL ';'",
"general_egdpool_path : EGDPOOL_PATH '=' QSTRING ';'",
"general_ping_cookie : PING_COOKIE '=' TBOOL ';'",
"general_disable_auth : DISABLE_AUTH '=' TBOOL ';'",
"general_throttle_time : THROTTLE_TIME '=' timespec ';'",
"$$27 :",
"general_oper_umodes : OPER_UMODES $$27 '=' umode_oitems ';'",
"umode_oitems : umode_oitems ',' umode_oitem",
"umode_oitems : umode_oitem",
"umode_oitem : T_BOTS",
"umode_oitem : T_CCONN",
"umode_oitem : T_DEAF",
"umode_oitem : T_DEBUG",
"umode_oitem : T_FULL",
"umode_oitem : T_SKILL",
"umode_oitem : T_NCHANGE",
"umode_oitem : T_REJ",
"umode_oitem : T_UNAUTH",
"umode_oitem : T_SPY",
"umode_oitem : T_EXTERNAL",
"umode_oitem : T_OPERWALL",
"umode_oitem : T_SERVNOTICE",
"umode_oitem : T_INVISIBLE",
"umode_oitem : T_WALLOP",
"umode_oitem : T_SOFTCALLERID",
"umode_oitem : T_CALLERID",
"umode_oitem : T_LOCOPS",
"$$28 :",
"general_oper_only_umodes : OPER_ONLY_UMODES $$28 '=' umode_items ';'",
"umode_items : umode_items ',' umode_item",
"umode_items : umode_item",
"umode_item : T_BOTS",
"umode_item : T_CCONN",
"umode_item : T_DEAF",
"umode_item : T_DEBUG",
"umode_item : T_FULL",
"umode_item : T_SKILL",
"umode_item : T_NCHANGE",
"umode_item : T_REJ",
"umode_item : T_UNAUTH",
"umode_item : T_SPY",
"umode_item : T_EXTERNAL",
"umode_item : T_OPERWALL",
"umode_item : T_SERVNOTICE",
"umode_item : T_INVISIBLE",
"umode_item : T_WALLOP",
"umode_item : T_SOFTCALLERID",
"umode_item : T_CALLERID",
"umode_item : T_LOCOPS",
"general_min_nonwildcard : MIN_NONWILDCARD '=' NUMBER ';'",
"general_min_nonwildcard_simple : MIN_NONWILDCARD_SIMPLE '=' NUMBER ';'",
"general_default_floodcount : DEFAULT_FLOODCOUNT '=' NUMBER ';'",
"general_client_flood : T_CLIENT_FLOOD '=' sizespec ';'",
"general_dot_in_ip6_addr : DOT_IN_IP6_ADDR '=' TBOOL ';'",
"$$29 :",
"gline_entry : GLINES $$29 '{' gline_items '}' ';'",
"gline_items : gline_items gline_item",
"gline_items : gline_item",
"gline_item : gline_enable",
"gline_item : gline_duration",
"gline_item : gline_logging",
"gline_item : gline_user",
"gline_item : gline_server",
"gline_item : gline_action",
"gline_item : error",
"gline_enable : ENABLE '=' TBOOL ';'",
"gline_duration : DURATION '=' timespec ';'",
"$$30 :",
"gline_logging : LOGGING $$30 '=' gline_logging_types ';'",
"gline_logging_types : gline_logging_types ',' gline_logging_type_item",
"gline_logging_types : gline_logging_type_item",
"gline_logging_type_item : T_REJECT",
"gline_logging_type_item : T_BLOCK",
"gline_user : USER '=' QSTRING ';'",
"gline_server : NAME '=' QSTRING ';'",
"$$31 :",
"gline_action : ACTION $$31 '=' gdeny_types ';'",
"gdeny_types : gdeny_types ',' gdeny_type_item",
"gdeny_types : gdeny_type_item",
"gdeny_type_item : T_REJECT",
"gdeny_type_item : T_BLOCK",
"channel_entry : CHANNEL '{' channel_items '}' ';'",
"channel_items : channel_items channel_item",
"channel_items : channel_item",
"channel_item : channel_disable_local_channels",
"channel_item : channel_use_except",
"channel_item : channel_use_invex",
"channel_item : channel_use_knock",
"channel_item : channel_max_bans",
"channel_item : channel_knock_delay",
"channel_item : channel_knock_delay_channel",
"channel_item : channel_max_chans_per_user",
"channel_item : channel_quiet_on_ban",
"channel_item : channel_default_split_user_count",
"channel_item : channel_default_split_server_count",
"channel_item : channel_no_create_on_split",
"channel_item : channel_restrict_channels",
"channel_item : channel_no_join_on_split",
"channel_item : channel_burst_topicwho",
"channel_item : channel_jflood_count",
"channel_item : channel_jflood_time",
"channel_item : error",
"channel_restrict_channels : RESTRICT_CHANNELS '=' TBOOL ';'",
"channel_disable_local_channels : DISABLE_LOCAL_CHANNELS '=' TBOOL ';'",
"channel_use_except : USE_EXCEPT '=' TBOOL ';'",
"channel_use_invex : USE_INVEX '=' TBOOL ';'",
"channel_use_knock : USE_KNOCK '=' TBOOL ';'",
"channel_knock_delay : KNOCK_DELAY '=' timespec ';'",
"channel_knock_delay_channel : KNOCK_DELAY_CHANNEL '=' timespec ';'",
"channel_max_chans_per_user : MAX_CHANS_PER_USER '=' NUMBER ';'",
"channel_quiet_on_ban : QUIET_ON_BAN '=' TBOOL ';'",
"channel_max_bans : MAX_BANS '=' NUMBER ';'",
"channel_default_split_user_count : DEFAULT_SPLIT_USER_COUNT '=' NUMBER ';'",
"channel_default_split_server_count : DEFAULT_SPLIT_SERVER_COUNT '=' NUMBER ';'",
"channel_no_create_on_split : NO_CREATE_ON_SPLIT '=' TBOOL ';'",
"channel_no_join_on_split : NO_JOIN_ON_SPLIT '=' TBOOL ';'",
"channel_burst_topicwho : BURST_TOPICWHO '=' TBOOL ';'",
"channel_jflood_count : JOIN_FLOOD_COUNT '=' NUMBER ';'",
"channel_jflood_time : JOIN_FLOOD_TIME '=' timespec ';'",
"serverhide_entry : SERVERHIDE '{' serverhide_items '}' ';'",
"serverhide_items : serverhide_items serverhide_item",
"serverhide_items : serverhide_item",
"serverhide_item : serverhide_flatten_links",
"serverhide_item : serverhide_hide_servers",
"serverhide_item : serverhide_links_delay",
"serverhide_item : serverhide_disable_hidden",
"serverhide_item : serverhide_hidden",
"serverhide_item : serverhide_hidden_name",
"serverhide_item : serverhide_hide_server_ips",
"serverhide_item : error",
"serverhide_flatten_links : FLATTEN_LINKS '=' TBOOL ';'",
"serverhide_hide_servers : HIDE_SERVERS '=' TBOOL ';'",
"serverhide_hidden_name : HIDDEN_NAME '=' QSTRING ';'",
"serverhide_links_delay : LINKS_DELAY '=' timespec ';'",
"serverhide_hidden : HIDDEN '=' TBOOL ';'",
"serverhide_disable_hidden : DISABLE_HIDDEN '=' TBOOL ';'",
"serverhide_hide_server_ips : HIDE_SERVER_IPS '=' TBOOL ';'",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#endif
#endif
#define YYINITSTACKSIZE 200
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short *yyss;
short *yysslim;
YYSTYPE *yyvs;
int yystacksize;
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack()
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = yyssp - yyss;
    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    yyss = newss;
    yyssp = newss + i;
    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab

#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#endif
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */

int
yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate])) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 25:
#line 412 "ircd_parser.y"
{ yyval.number = 0; }
break;
case 27:
#line 414 "ircd_parser.y"
{
			yyval.number = yyvsp[-1].number + yyvsp[0].number;
		}
break;
case 28:
#line 418 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number + yyvsp[0].number;
		}
break;
case 29:
#line 422 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 + yyvsp[0].number;
		}
break;
case 30:
#line 426 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 + yyvsp[0].number;
		}
break;
case 31:
#line 430 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 * 24 + yyvsp[0].number;
		}
break;
case 32:
#line 434 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 * 24 * 7 + yyvsp[0].number;
		}
break;
case 33:
#line 439 "ircd_parser.y"
{ yyval.number = 0; }
break;
case 35:
#line 440 "ircd_parser.y"
{ yyval.number = yyvsp[-1].number + yyvsp[0].number; }
break;
case 36:
#line 441 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number + yyvsp[0].number; }
break;
case 37:
#line 442 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number * 1024 + yyvsp[0].number; }
break;
case 38:
#line 443 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number * 1024 * 1024 + yyvsp[0].number; }
break;
case 45:
#line 457 "ircd_parser.y"
{
#ifndef STATIC_MODULES /* NOOP in the static case */
  if (ypass == 2)
  {
    char *m_bn;

    m_bn = basename(yylval.string);

    /* I suppose we should just ignore it if it is already loaded(since
     * otherwise we would flood the opers on rehash) -A1kmm.
     */
    add_conf_module(yylval.string);
  }
#endif
}
break;
case 46:
#line 474 "ircd_parser.y"
{
#ifndef STATIC_MODULES
  if (ypass == 2)
    mod_add_path(yylval.string);
#endif
}
break;
case 62:
#line 498 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2 && ServerInfo.ctx) 
  {
    if (!ServerInfo.rsa_private_key_file)
    {
      yyerror("No rsa_private_key_file specified, SSL disabled");
      break;
    }

    if (SSL_CTX_use_certificate_file(ServerInfo.ctx,
      yylval.string, SSL_FILETYPE_PEM) <= 0)
    {
      yyerror(ERR_lib_error_string(ERR_get_error()));
      break;
    }

    if (SSL_CTX_use_PrivateKey_file(ServerInfo.ctx,
      ServerInfo.rsa_private_key_file, SSL_FILETYPE_PEM) <= 0)
    {
      yyerror(ERR_lib_error_string(ERR_get_error()));
      break;
    }

    if (!SSL_CTX_check_private_key(ServerInfo.ctx))
    {
      yyerror("RSA private key does not match the SSL certificate public key!");
      break;
    }
  }
#endif
}
break;
case 63:
#line 532 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 1)
  {
    BIO *file;

    if (ServerInfo.rsa_private_key)
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;
    }

    if (ServerInfo.rsa_private_key_file)
    {
      MyFree(ServerInfo.rsa_private_key_file);
      ServerInfo.rsa_private_key_file = NULL;
    }

    DupString(ServerInfo.rsa_private_key_file, yylval.string);

    if ((file = BIO_new_file(yylval.string, "r")) == NULL)
    {
      yyerror("File open failed, ignoring");
      break;
    }

    ServerInfo.rsa_private_key = (RSA *)PEM_read_bio_RSAPrivateKey(file, NULL,
      0, NULL);

    BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);

    if (ServerInfo.rsa_private_key == NULL)
    {
      yyerror("Couldn't extract key, ignoring");
      break;
    }

    if (!RSA_check_key(ServerInfo.rsa_private_key))
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;

      yyerror("Invalid key, ignoring");
      break;
    }

    /* require 2048 bit (256 byte) key */
    if (RSA_size(ServerInfo.rsa_private_key) != 256)
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;

      yyerror("Not a 2048 bit key, ignoring");
    }
  }
#endif
}
break;
case 64:
#line 592 "ircd_parser.y"
{
  /* this isn't rehashable */
  if (ypass == 2)
  {
    if (ServerInfo.name == NULL)
    {
      /* the ircd will exit() in main() if we dont set one */
      if (strlen(yylval.string) <= HOSTLEN)
        DupString(ServerInfo.name, yylval.string);
    }
  }
}
break;
case 65:
#line 606 "ircd_parser.y"
{
  /* this isn't rehashable */
  if (ypass == 2 && !ServerInfo.sid)
  {
    if ((strlen(yylval.string) == IRC_MAXSID) && IsDigit(yylval.string[0])
	&& IsAlNum(yylval.string[1]) && IsAlNum(yylval.string[2]))
    {
      DupString(ServerInfo.sid, yylval.string);
    }
    else
    {
      ilog(L_ERROR, "Ignoring config file entry SID -- invalid SID. Aborting.");
      exit(0);
    }
  }
}
break;
case 66:
#line 624 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ServerInfo.description);
    DupString(ServerInfo.description,yylval.string);
  }
}
break;
case 67:
#line 633 "ircd_parser.y"
{
  if (ypass == 2)
  {
    char *p;

    if ((p = strchr(yylval.string, ' ')) != NULL)
      p = '\0';

    MyFree(ServerInfo.network_name);
    DupString(ServerInfo.network_name, yylval.string);
  }
}
break;
case 68:
#line 647 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ServerInfo.network_desc);
    DupString(ServerInfo.network_desc, yylval.string);
  }
}
break;
case 69:
#line 656 "ircd_parser.y"
{
  if (ypass == 2 && *yylval.string != '*')
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&ServerInfo.ip, res->ai_addr, res->ai_addrlen);
      ServerInfo.ip.ss.ss_family = res->ai_family;
      ServerInfo.ip.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);

      ServerInfo.specific_ipv4_vhost = 1;
    }
  }
}
break;
case 70:
#line 684 "ircd_parser.y"
{
#ifdef IPV6
  if (ypass == 2 && *yylval.string != '*')
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost6(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&ServerInfo.ip6, res->ai_addr, res->ai_addrlen);
      ServerInfo.ip6.ss.ss_family = res->ai_family;
      ServerInfo.ip6.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);

      ServerInfo.specific_ipv6_vhost = 1;
    }
  }
#endif
}
break;
case 71:
#line 714 "ircd_parser.y"
{
  if (ypass == 2)
  {
    recalc_fdlimit(NULL);

    if (yyvsp[-1].number < MAXCLIENTS_MIN)
    {
      char buf[IRCD_BUFSIZE];
      ircsprintf(buf, "MAXCLIENTS too low, setting to %d", MAXCLIENTS_MIN);
      yyerror(buf);
    }
    else if (yyvsp[-1].number > MAXCLIENTS_MAX)
    {
      char buf[IRCD_BUFSIZE];
      ircsprintf(buf, "MAXCLIENTS too high, setting to %d", MAXCLIENTS_MAX);
      yyerror(buf);
    }
    else
      ServerInfo.max_clients = yyvsp[-1].number;
  }
}
break;
case 72:
#line 737 "ircd_parser.y"
{
  if (ypass == 2 && ServerInfo.hub != yylval.number)
  {
    if ((ServerInfo.hub = yylval.number))
    {
      /* Don't become a hub if we have an LL uplink. */
      if (uplink != NULL)
      {
        ServerInfo.hub = NO;
        sendto_realops_flags(UMODE_ALL, L_ALL,
                             "Ignoring config file line hub=yes; "
                             "due to active LazyLink (%s)", uplink->name);
      }
    }
    else
    {
      dlink_node *ptr = NULL;

      /* Don't become a leaf if we have a lazylink active. */
      DLINK_FOREACH(ptr, serv_list.head)
      {
        struct Client *acptr = ptr->data;

        if (MyConnect(acptr) && IsCapable(acptr, CAP_LL))
        {
          ServerInfo.hub = YES;
          sendto_realops_flags(UMODE_ALL, L_ALL,
                               "Ignoring config file line hub=no; "
                               "due to active LazyLink (%s)",
                               acptr->name);
          break;
        }
      }
    }
  }
}
break;
case 80:
#line 784 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.name);
    DupString(AdminInfo.name, yylval.string);
  }
}
break;
case 81:
#line 793 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.email);
    DupString(AdminInfo.email, yylval.string);
  }
}
break;
case 82:
#line 802 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.description);
    DupString(AdminInfo.description, yylval.string);
  }
}
break;
case 99:
#line 829 "ircd_parser.y"
{
                        }
break;
case 100:
#line 833 "ircd_parser.y"
{
                        }
break;
case 101:
#line 837 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.userlog, yylval.string,
            sizeof(ConfigLoggingEntry.userlog));
}
break;
case 102:
#line 844 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.failed_operlog, yylval.string,
            sizeof(ConfigLoggingEntry.failed_operlog));
}
break;
case 103:
#line 851 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.operlog, yylval.string,
            sizeof(ConfigLoggingEntry.operlog));
}
break;
case 104:
#line 858 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.operspylog, yylval.string,
            sizeof(ConfigLoggingEntry.operspylog));
}
break;
case 105:
#line 865 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.glinelog, yylval.string,
            sizeof(ConfigLoggingEntry.glinelog));
}
break;
case 106:
#line 872 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.klinelog, yylval.string,
            sizeof(ConfigLoggingEntry.klinelog));
}
break;
case 107:
#line 879 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.ioerrlog, yylval.string,
            sizeof(ConfigLoggingEntry.ioerrlog));
}
break;
case 108:
#line 886 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.killlog, yylval.string,
            sizeof(ConfigLoggingEntry.killlog));
}
break;
case 109:
#line 893 "ircd_parser.y"
{ 
  if (ypass == 2)
    set_log_level(L_CRIT);
}
break;
case 110:
#line 897 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_ERROR);
}
break;
case 111:
#line 901 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_WARN);
}
break;
case 112:
#line 905 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_NOTICE);
}
break;
case 113:
#line 909 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_TRACE);
}
break;
case 114:
#line 913 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_INFO);
}
break;
case 115:
#line 917 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_DEBUG);
}
break;
case 116:
#line 923 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigLoggingEntry.use_logging = yylval.number;
}
break;
case 117:
#line 932 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(OPER_TYPE);
    yy_aconf = &yy_conf->conf.AccessItem;
    SetConfEncrypted(yy_aconf); /* Yes, the default is encrypted */
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 118:
#line 945 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;
    dlink_node *ptr;
    dlink_node *next_ptr;

    conf_add_class_to_conf(yy_conf, class_name);

    /* Now, make sure there is a copy of the "base" given oper
     * block in each of the collected copies
     */

    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;
      yy_tmp = ptr->data;

      new_conf = make_conf_item(OPER_TYPE);
      new_aconf = &new_conf->conf.AccessItem;

      new_aconf->flags = yy_aconf->flags;

      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      if (yy_tmp->user != NULL)
	DupString(new_aconf->user, yy_tmp->user);
      else
	DupString(new_aconf->user, "*");
      if (yy_tmp->host != NULL)
	DupString(new_aconf->host, yy_tmp->host);
      else
	DupString(new_aconf->host, "*");
      conf_add_class_to_conf(new_conf, class_name);
      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);

      new_aconf->port = yy_aconf->port;
#ifdef HAVE_LIBCRYPTO
      if (yy_aconf->rsa_public_key_file != NULL)
      {
        BIO *file;

        DupString(new_aconf->rsa_public_key_file,
		  yy_aconf->rsa_public_key_file);

        file = BIO_new_file(yy_aconf->rsa_public_key_file, "r");
        new_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, 
							   NULL, 0, NULL);
        BIO_set_close(file, BIO_CLOSE);
        BIO_free(file);
      }
#endif

#ifdef HAVE_LIBCRYPTO
      if (yy_tmp->name && (yy_tmp->passwd || yy_aconf->rsa_public_key)
	  && yy_tmp->host)
#else
      if (yy_tmp->name && yy_tmp->passwd && yy_tmp->host)
#endif
      {
        conf_add_class_to_conf(new_conf, class_name);
	if (yy_tmp->name != NULL)
	  DupString(new_conf->name, yy_tmp->name);
      }

      dlinkDelete(&yy_tmp->node, &col_conf_list);
      free_collect_item(yy_tmp);
    }

    yy_conf = NULL;
    yy_aconf = NULL;


    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 146:
#line 1037 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > OPERNICKLEN)
      yylval.string[OPERNICKLEN] = '\0';

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 147:
#line 1049 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > OPERNICKLEN)
      yylval.string[OPERNICKLEN] = '\0';

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 148:
#line 1061 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    if (yy_aconf->user == NULL)
    {
      split_nuh(yylval.string, NULL, &yy_aconf->user, &yy_aconf->host);
    }
    else
    {
      yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
      split_nuh(yylval.string, NULL, &yy_tmp->user, &yy_tmp->host);
      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 149:
#line 1080 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 150:
#line 1092 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      SetConfEncrypted(yy_aconf);
    else
      ClearConfEncrypted(yy_aconf);
  }
}
break;
case 151:
#line 1103 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (yy_aconf->rsa_public_key != NULL)
    {
      RSA_free(yy_aconf->rsa_public_key);
      yy_aconf->rsa_public_key = NULL;
    }

    if (yy_aconf->rsa_public_key_file != NULL)
    {
      MyFree(yy_aconf->rsa_public_key_file);
      yy_aconf->rsa_public_key_file = NULL;
    }

    DupString(yy_aconf->rsa_public_key_file, yylval.string);
    file = BIO_new_file(yylval.string, "r");

    if (file == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- file doesn't exist");
      break;
    }

    yy_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, NULL, 0, NULL);

    if (yy_aconf->rsa_public_key == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- Key invalid; check key syntax.");
      break;
    }

    BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif /* HAVE_LIBCRYPTO */
}
break;
case 152:
#line 1145 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 153:
#line 1154 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes = 0;
}
break;
case 157:
#line 1161 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_BOTS;
}
break;
case 158:
#line 1165 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_CCONN;
}
break;
case 159:
#line 1169 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_DEAF;
}
break;
case 160:
#line 1173 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_DEBUG;
}
break;
case 161:
#line 1177 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_FULL;
}
break;
case 162:
#line 1181 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SKILL;
}
break;
case 163:
#line 1185 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_NCHANGE;
}
break;
case 164:
#line 1189 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_REJ;
}
break;
case 165:
#line 1193 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_UNAUTH;
}
break;
case 166:
#line 1197 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SPY;
}
break;
case 167:
#line 1201 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_EXTERNAL;
}
break;
case 168:
#line 1205 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_OPERWALL;
}
break;
case 169:
#line 1209 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SERVNOTICE;
}
break;
case 170:
#line 1213 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_INVISIBLE;
}
break;
case 171:
#line 1217 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_WALLOP;
}
break;
case 172:
#line 1221 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SOFTCALLERID;
}
break;
case 173:
#line 1225 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_CALLERID;
}
break;
case 174:
#line 1229 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_LOCOPS;
}
break;
case 175:
#line 1235 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_GLOBAL_KILL;
    else
      yy_aconf->port &= ~OPER_FLAG_GLOBAL_KILL;
  }
}
break;
case 176:
#line 1246 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REMOTE;
    else
      yy_aconf->port &= ~OPER_FLAG_REMOTE; 
  }
}
break;
case 177:
#line 1257 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REMOTEBAN;
    else
      yy_aconf->port &= ~OPER_FLAG_REMOTEBAN;
  }
}
break;
case 178:
#line 1268 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_K;
    else
      yy_aconf->port &= ~OPER_FLAG_K;
  }
}
break;
case 179:
#line 1279 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_X;
    else
      yy_aconf->port &= ~OPER_FLAG_X;
  }
}
break;
case 180:
#line 1290 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_UNKLINE;
    else
      yy_aconf->port &= ~OPER_FLAG_UNKLINE; 
  }
}
break;
case 181:
#line 1301 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_GLINE;
    else
      yy_aconf->port &= ~OPER_FLAG_GLINE;
  }
}
break;
case 182:
#line 1312 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_N;
    else
      yy_aconf->port &= ~OPER_FLAG_N;
  }
}
break;
case 183:
#line 1323 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_DIE;
    else
      yy_aconf->port &= ~OPER_FLAG_DIE;
  }
}
break;
case 184:
#line 1334 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REHASH;
    else
      yy_aconf->port &= ~OPER_FLAG_REHASH;
  }
}
break;
case 185:
#line 1345 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_ADMIN;
    else
      yy_aconf->port &= ~OPER_FLAG_ADMIN;
  }
}
break;
case 186:
#line 1356 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_HIDDEN_ADMIN;
    else
      yy_aconf->port &= ~OPER_FLAG_HIDDEN_ADMIN;
  }
}
break;
case 187:
#line 1367 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_HIDDEN_OPER;
    else
      yy_aconf->port &= ~OPER_FLAG_HIDDEN_OPER;
  }
}
break;
case 188:
#line 1378 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_OPERWALL;
    else
      yy_aconf->port &= ~OPER_FLAG_OPERWALL;
  }
}
break;
case 189:
#line 1389 "ircd_parser.y"
{
}
break;
case 193:
#line 1393 "ircd_parser.y"
{ not_atom = 1; }
break;
case 195:
#line 1394 "ircd_parser.y"
{ not_atom = 0; }
break;
case 197:
#line 1397 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)yy_aconf->port &= ~OPER_FLAG_GLOBAL_KILL;
    else yy_aconf->port |= OPER_FLAG_GLOBAL_KILL;
  }
}
break;
case 198:
#line 1404 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REMOTE;
    else yy_aconf->port |= OPER_FLAG_REMOTE;
  }
}
break;
case 199:
#line 1411 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_K;
    else yy_aconf->port |= OPER_FLAG_K;
  }
}
break;
case 200:
#line 1418 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_UNKLINE;
    else yy_aconf->port |= OPER_FLAG_UNKLINE;
  } 
}
break;
case 201:
#line 1425 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_X;
    else yy_aconf->port |= OPER_FLAG_X;
  }
}
break;
case 202:
#line 1432 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_GLINE;
    else yy_aconf->port |= OPER_FLAG_GLINE;
  }
}
break;
case 203:
#line 1439 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_DIE;
    else yy_aconf->port |= OPER_FLAG_DIE;
  }
}
break;
case 204:
#line 1446 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REHASH;
    else yy_aconf->port |= OPER_FLAG_REHASH;
  }
}
break;
case 205:
#line 1453 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_ADMIN;
    else yy_aconf->port |= OPER_FLAG_ADMIN;
  }
}
break;
case 206:
#line 1460 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_HIDDEN_ADMIN;
    else yy_aconf->port |= OPER_FLAG_HIDDEN_ADMIN;
  }
}
break;
case 207:
#line 1467 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_N;
    else yy_aconf->port |= OPER_FLAG_N;
  }
}
break;
case 208:
#line 1474 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_OPERWALL;
    else yy_aconf->port |= OPER_FLAG_OPERWALL;
  }
}
break;
case 209:
#line 1481 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_OPER_SPY;
    else yy_aconf->port |= OPER_FLAG_OPER_SPY;
  }
}
break;
case 210:
#line 1488 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_HIDDEN_OPER;
    else yy_aconf->port |= OPER_FLAG_HIDDEN_OPER;
  }
}
break;
case 211:
#line 1495 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REMOTEBAN;
    else yy_aconf->port |= OPER_FLAG_REMOTEBAN;
  }
}
break;
case 212:
#line 1502 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) ClearConfEncrypted(yy_aconf);
    else SetConfEncrypted(yy_aconf);
  }
}
break;
case 213:
#line 1515 "ircd_parser.y"
{
  if (ypass == 1)
  {
    yy_conf = make_conf_item(CLASS_TYPE);
    yy_class = &yy_conf->conf.ClassItem;
  }
}
break;
case 214:
#line 1522 "ircd_parser.y"
{
  if (ypass == 1)
  {
    struct ConfItem *cconf;
    struct ClassItem *class = NULL;

    if (yy_class_name == NULL)
    {
      delete_conf_item(yy_conf);
    }
    else
    {
      cconf = find_exact_name_conf(CLASS_TYPE, yy_class_name, NULL, NULL);

      if (cconf != NULL)		/* The class existed already */
      {
        class = &cconf->conf.ClassItem;
        rebuild_cidr_class(class, yy_class);
        *class = *yy_class;
        delete_conf_item(yy_conf);

        MyFree(cconf->name);            /* Allows case change of class name */
        cconf->name = yy_class_name;
      }
      else	/* Brand new class */
      {
        MyFree(yy_conf->name);          /* just in case it was allocated */
        yy_conf->name = yy_class_name;
      }
    }
    yy_class_name = NULL;
  }
}
break;
case 233:
#line 1574 "ircd_parser.y"
{
  if (ypass == 1)
  {
    MyFree(yy_class_name);
    DupString(yy_class_name, yylval.string);
  }
}
break;
case 234:
#line 1583 "ircd_parser.y"
{
  if (ypass == 1)
  {
    MyFree(yy_class_name);
    DupString(yy_class_name, yylval.string);
  }
}
break;
case 235:
#line 1592 "ircd_parser.y"
{
  if (ypass == 1)
    PingFreq(yy_class) = yyvsp[-1].number;
}
break;
case 236:
#line 1598 "ircd_parser.y"
{
  if (ypass == 1)
    PingWarning(yy_class) = yyvsp[-1].number;
}
break;
case 237:
#line 1604 "ircd_parser.y"
{
  if (ypass == 1)
    MaxPerIp(yy_class) = yyvsp[-1].number;
}
break;
case 238:
#line 1610 "ircd_parser.y"
{
  if (ypass == 1)
    ConFreq(yy_class) = yyvsp[-1].number;
}
break;
case 239:
#line 1616 "ircd_parser.y"
{
  if (ypass == 1)
    MaxTotal(yy_class) = yyvsp[-1].number;
}
break;
case 240:
#line 1622 "ircd_parser.y"
{
  if (ypass == 1)
    MaxGlobal(yy_class) = yyvsp[-1].number;
}
break;
case 241:
#line 1628 "ircd_parser.y"
{
  if (ypass == 1)
    MaxLocal(yy_class) = yyvsp[-1].number;
}
break;
case 242:
#line 1634 "ircd_parser.y"
{
  if (ypass == 1)
    MaxIdent(yy_class) = yyvsp[-1].number;
}
break;
case 243:
#line 1640 "ircd_parser.y"
{
  if (ypass == 1)
    MaxSendq(yy_class) = yyvsp[-1].number;
}
break;
case 244:
#line 1646 "ircd_parser.y"
{
  if (ypass == 1)
    CidrBitlenIPV4(yy_class) = yyvsp[-1].number;
}
break;
case 245:
#line 1652 "ircd_parser.y"
{
  if (ypass == 1)
    CidrBitlenIPV6(yy_class) = yyvsp[-1].number;
}
break;
case 246:
#line 1658 "ircd_parser.y"
{
  if (ypass == 1)
    NumberPerCidr(yy_class) = yyvsp[-1].number;
}
break;
case 247:
#line 1667 "ircd_parser.y"
{
  if (ypass == 2)
  {
    listener_address = NULL;
    listener_flags = 0;
  }
}
break;
case 248:
#line 1674 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    listener_address = NULL;
  }
}
break;
case 249:
#line 1683 "ircd_parser.y"
{
}
break;
case 253:
#line 1688 "ircd_parser.y"
{
  if (ypass == 2)
    listener_flags |= LISTENER_SSL;
}
break;
case 254:
#line 1692 "ircd_parser.y"
{
  if (ypass == 2)
    listener_flags |= LISTENER_HIDDEN;
}
break;
case 265:
#line 1705 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if ((listener_flags & LISTENER_SSL))
#ifdef HAVE_LIBCRYPTO
      if (!ServerInfo.ctx)
#endif
      {
        yyerror("SSL not available - port closed");
	break;
      }
    add_listener(yyvsp[0].number, listener_address, listener_flags);
    listener_flags = 0;
  }
}
break;
case 266:
#line 1720 "ircd_parser.y"
{
  if (ypass == 2)
  {
    int i;

    if ((listener_flags & LISTENER_SSL))
#ifdef HAVE_LIBCRYPTO
      if (!ServerInfo.ctx)
#endif
      {
        yyerror("SSL not available - port closed");
	break;
      }

    for (i = yyvsp[-2].number; i <= yyvsp[0].number; ++i)
      add_listener(i, listener_address, listener_flags);

    listener_flags = 0;
  }
}
break;
case 267:
#line 1742 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    DupString(listener_address, yylval.string);
  }
}
break;
case 268:
#line 1751 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    DupString(listener_address, yylval.string);
  }
}
break;
case 269:
#line 1763 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(CLIENT_TYPE);
    yy_aconf = &yy_conf->conf.AccessItem;
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 270:
#line 1775 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp = NULL;
    dlink_node *ptr = NULL, *next_ptr = NULL;

    if (yy_aconf->user && yy_aconf->host)
    {
      conf_add_class_to_conf(yy_conf, class_name);
      add_conf_by_address(CONF_CLIENT, yy_aconf);
    }
    else
      delete_conf_item(yy_conf);

    /* copy over settings from first struct */
    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;

      new_conf = make_conf_item(CLIENT_TYPE);
      new_aconf = &new_conf->conf.AccessItem;

      yy_tmp = ptr->data;

      assert(yy_tmp->user && yy_tmp->host);

      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);
      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);

      new_aconf->flags = yy_aconf->flags;
      new_aconf->port  = yy_aconf->port;

      DupString(new_aconf->user, yy_tmp->user);
      collapse(new_aconf->user);

      DupString(new_aconf->host, yy_tmp->host);
      collapse(new_aconf->host);

      conf_add_class_to_conf(new_conf, class_name);
      add_conf_by_address(CONF_CLIENT, new_aconf);
      dlinkDelete(&yy_tmp->node, &col_conf_list);
      free_collect_item(yy_tmp);
    }

    MyFree(class_name);
    class_name = NULL;
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 290:
#line 1840 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    if (yy_aconf->user == NULL)
      split_nuh(yylval.string, NULL, &yy_aconf->user, &yy_aconf->host);
    else
    {
      yy_tmp = MyMalloc(sizeof(struct CollectItem));
      split_nuh(yylval.string, NULL, &yy_tmp->user, &yy_tmp->host);
      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 291:
#line 1859 "ircd_parser.y"
{
  if (ypass == 2)
  {
    /* be paranoid */
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 292:
#line 1872 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_SPOOF_NOTICE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_SPOOF_NOTICE;
  }
}
break;
case 293:
#line 1883 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 294:
#line 1892 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      SetConfEncrypted(yy_aconf);
    else
      ClearConfEncrypted(yy_aconf);
  }
}
break;
case 295:
#line 1903 "ircd_parser.y"
{
}
break;
case 299:
#line 1907 "ircd_parser.y"
{ not_atom = 1; }
break;
case 301:
#line 1908 "ircd_parser.y"
{ not_atom = 0; }
break;
case 303:
#line 1911 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_SPOOF_NOTICE;
    else yy_aconf->flags |= CONF_FLAGS_SPOOF_NOTICE;
  }

}
break;
case 304:
#line 1919 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NOLIMIT;
    else yy_aconf->flags |= CONF_FLAGS_NOLIMIT;
  }
}
break;
case 305:
#line 1926 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTKLINE;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTKLINE;
  } 
}
break;
case 306:
#line 1933 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NEED_IDENTD;
    else yy_aconf->flags |= CONF_FLAGS_NEED_IDENTD;
  }
}
break;
case 307:
#line 1940 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_CAN_FLOOD;
    else yy_aconf->flags |= CONF_FLAGS_CAN_FLOOD;
  }
}
break;
case 308:
#line 1947 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_IDLE_LINED;
    else yy_aconf->flags |= CONF_FLAGS_IDLE_LINED;
  }
}
break;
case 309:
#line 1954 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NO_TILDE;
    else yy_aconf->flags |= CONF_FLAGS_NO_TILDE;
  } 
}
break;
case 310:
#line 1961 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTGLINE;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTGLINE;
  } 
}
break;
case 311:
#line 1968 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTRESV;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTRESV;
  }
}
break;
case 312:
#line 1975 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NEED_PASSWORD;
    else yy_aconf->flags |= CONF_FLAGS_NEED_PASSWORD;
  }
}
break;
case 313:
#line 1984 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_EXEMPTKLINE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_EXEMPTKLINE;
  }
}
break;
case 314:
#line 1995 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NEED_IDENTD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NEED_IDENTD;
  }
}
break;
case 315:
#line 2006 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NOLIMIT;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NOLIMIT;
  }
}
break;
case 316:
#line 2017 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_CAN_FLOOD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_CAN_FLOOD;
  }
}
break;
case 317:
#line 2028 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NO_TILDE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NO_TILDE;
  }
}
break;
case 318:
#line 2039 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_EXEMPTGLINE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_EXEMPTGLINE;
  }
}
break;
case 319:
#line 2051 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);

    if (strlen(yylval.string) < HOSTLEN)
    {    
      DupString(yy_conf->name, yylval.string);
      yy_aconf->flags |= CONF_FLAGS_SPOOF_IP;
    }
    else
    {
      ilog(L_ERROR, "Spoofs must be less than %d..ignoring it", HOSTLEN);
      yy_conf->name = NULL;
    }
  }
}
break;
case 320:
#line 2070 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_aconf->flags |= CONF_FLAGS_REDIR;
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 321:
#line 2080 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_aconf->flags |= CONF_FLAGS_REDIR;
    yy_aconf->port = yyvsp[-1].number;
  }
}
break;
case 322:
#line 2089 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NEED_PASSWORD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NEED_PASSWORD;
  }
}
break;
case 323:
#line 2104 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    resv_reason = NULL;
  }
}
break;
case 324:
#line 2111 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    resv_reason = NULL;
  }
}
break;
case 331:
#line 2123 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    DupString(resv_reason, yylval.string);
  }
}
break;
case 332:
#line 2132 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (IsChanPrefix(*yylval.string))
    {
      char def_reason[] = "No reason";

      create_channel_resv(yylval.string, resv_reason != NULL ? resv_reason : def_reason, 1);
    }
  }
  /* ignore it for now.. but we really should make a warning if
   * its an erroneous name --fl_ */
}
break;
case 333:
#line 2147 "ircd_parser.y"
{
  if (ypass == 2)
  {
    char def_reason[] = "No reason";

    create_nick_resv(yylval.string, resv_reason != NULL ? resv_reason : def_reason, 1);
  }
}
break;
case 334:
#line 2160 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(ULINE_TYPE);
    yy_match_item = &yy_conf->conf.MatchItem;
    yy_match_item->action = SHARED_ALL;
  }
}
break;
case 335:
#line 2168 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = NULL;
  }
}
break;
case 342:
#line 2179 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 343:
#line 2188 "ircd_parser.y"
{
  if (ypass == 2)
  {
    split_nuh(yylval.string, NULL, &yy_match_item->user, &yy_match_item->host);
  }
}
break;
case 344:
#line 2196 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = 0;
}
break;
case 348:
#line 2203 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_KLINE;
}
break;
case 349:
#line 2207 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TKLINE;
}
break;
case 350:
#line 2211 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNKLINE;
}
break;
case 351:
#line 2215 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_XLINE;
}
break;
case 352:
#line 2219 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TXLINE;
}
break;
case 353:
#line 2223 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNXLINE;
}
break;
case 354:
#line 2227 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_RESV;
}
break;
case 355:
#line 2231 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TRESV;
}
break;
case 356:
#line 2235 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNRESV;
}
break;
case 357:
#line 2239 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_LOCOPS;
}
break;
case 358:
#line 2243 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = SHARED_ALL;
}
break;
case 359:
#line 2252 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(CLUSTER_TYPE);
    yy_match_item = &yy_conf->conf.MatchItem;
    yy_match_item->action = SHARED_ALL;
    DupString(yy_conf->name, "*");
  }
}
break;
case 360:
#line 2261 "ircd_parser.y"
{
  yy_conf = NULL;
  yy_match_item = NULL;
}
break;
case 366:
#line 2270 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 367:
#line 2279 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = 0;
}
break;
case 371:
#line 2286 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_KLINE;
}
break;
case 372:
#line 2290 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TKLINE;
}
break;
case 373:
#line 2294 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNKLINE;
}
break;
case 374:
#line 2298 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_XLINE;
}
break;
case 375:
#line 2302 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TXLINE;
}
break;
case 376:
#line 2306 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNXLINE;
}
break;
case 377:
#line 2310 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_RESV;
}
break;
case 378:
#line 2314 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TRESV;
}
break;
case 379:
#line 2318 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNRESV;
}
break;
case 380:
#line 2322 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_LOCOPS;
}
break;
case 381:
#line 2326 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = SHARED_ALL;
}
break;
case 382:
#line 2335 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(SERVER_TYPE);
    yy_aconf = &yy_conf->conf.AccessItem;
    yy_aconf->passwd = NULL;
    /* defaults */
    yy_aconf->port = PORTNUM;

    if (ConfigFileEntry.burst_away)
      yy_aconf->flags = CONF_FLAGS_BURST_AWAY;
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 383:
#line 2353 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_hconf=NULL;
    struct CollectItem *yy_lconf=NULL;
    dlink_node *ptr;
    dlink_node *next_ptr;
#ifdef HAVE_LIBCRYPTO
    if (yy_aconf->host &&
	((yy_aconf->passwd && yy_aconf->spasswd) ||
	 (yy_aconf->rsa_public_key && IsConfCryptLink(yy_aconf))))
#else /* !HAVE_LIBCRYPTO */
      if (yy_aconf->host && !IsConfCryptLink(yy_aconf) && 
	  yy_aconf->passwd && yy_aconf->spasswd)
#endif /* !HAVE_LIBCRYPTO */
	{
	  if (conf_add_server(yy_conf, scount, class_name) >= 0)
	  {
	    ++scount;
	  }
	  else
	  {
	    delete_conf_item(yy_conf);
	    yy_conf = NULL;
	    yy_aconf = NULL;
	  }
	}
	else
	{
	  /* Even if yy_conf ->name is NULL
	   * should still unhook any hub/leaf confs still pending
	   */
	  unhook_hub_leaf_confs();

	  if (yy_conf->name != NULL)
	  {
#ifndef HAVE_LIBCRYPTO
	    if (IsConfCryptLink(yy_aconf))
	      yyerror("Ignoring connect block -- no OpenSSL support");
#else
	    if (IsConfCryptLink(yy_aconf) && !yy_aconf->rsa_public_key)
	      yyerror("Ignoring connect block -- missing key");
#endif
	    if (yy_aconf->host == NULL)
	      yyerror("Ignoring connect block -- missing host");
	    else if (!IsConfCryptLink(yy_aconf) && 
		    (!yy_aconf->passwd || !yy_aconf->spasswd))
              yyerror("Ignoring connect block -- missing password");
	  }


          /* XXX
           * This fixes a try_connections() core (caused by invalid class_ptr
           * pointers) reported by metalrock. That's an ugly fix, but there
           * is currently no better way. The entire config subsystem needs an
           * rewrite ASAP. make_conf_item() shouldn't really add things onto
           * a doubly linked list immediately without any sanity checks!  -Michael
           */
          delete_conf_item(yy_conf);

          yy_aconf = NULL;
	  yy_conf = NULL;
	}

      /*
       * yy_conf is still pointing at the server that is having
       * a connect block built for it. This means, y_aconf->name 
       * points to the actual irc name this server will be known as.
       * Now this new server has a set or even just one hub_mask (or leaf_mask)
       * given in the link list at yy_hconf. Fill in the HUB confs
       * from this link list now.
       */        
      DLINK_FOREACH_SAFE(ptr, next_ptr, hub_conf_list.head)
      {
	struct ConfItem *new_hub_conf;
	struct MatchItem *match_item;

	yy_hconf = ptr->data;

	/* yy_conf == NULL is a fatal error for this connect block! */
	if ((yy_conf != NULL) && (yy_conf->name != NULL))
	{
	  new_hub_conf = make_conf_item(HUB_TYPE);
	  match_item = &new_hub_conf->conf.MatchItem;
	  DupString(new_hub_conf->name, yy_conf->name);
	  if (yy_hconf->user != NULL)
	    DupString(match_item->user, yy_hconf->user);
	  else
	    DupString(match_item->user, "*");
	  if (yy_hconf->host != NULL)
	    DupString(match_item->host, yy_hconf->host);
	  else
	    DupString(match_item->host, "*");
	}
	dlinkDelete(&yy_hconf->node, &hub_conf_list);
	free_collect_item(yy_hconf);
      }

      /* Ditto for the LEAF confs */

      DLINK_FOREACH_SAFE(ptr, next_ptr, leaf_conf_list.head)
      {
	struct ConfItem *new_leaf_conf;
	struct MatchItem *match_item;

	yy_lconf = ptr->data;

	if ((yy_conf != NULL) && (yy_conf->name != NULL))
	{
	  new_leaf_conf = make_conf_item(LEAF_TYPE);
	  match_item = &new_leaf_conf->conf.MatchItem;
	  DupString(new_leaf_conf->name, yy_conf->name);
	  if (yy_lconf->user != NULL)
	    DupString(match_item->user, yy_lconf->user);
	  else
	    DupString(match_item->user, "*");
	  if (yy_lconf->host != NULL)
	    DupString(match_item->host, yy_lconf->host);
	  else
	    DupString(match_item->host, "*");
	}
	dlinkDelete(&yy_lconf->node, &leaf_conf_list);
	free_collect_item(yy_lconf);
      }
      MyFree(class_name);
      class_name = NULL;
      yy_conf = NULL;
      yy_aconf = NULL;
  }
}
break;
case 407:
#line 2496 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name != NULL)
      yyerror("Multiple connect name entry");

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 408:
#line 2508 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name != NULL)
      yyerror("Multiple connect name entry");

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 409:
#line 2520 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 410:
#line 2529 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&yy_aconf->my_ipnum, res->ai_addr, res->ai_addrlen);
      yy_aconf->my_ipnum.ss.ss_family = res->ai_family;
      yy_aconf->my_ipnum.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);
    }
  }
}
break;
case 411:
#line 2555 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yyvsp[-1].string[0] == ':')
      yyerror("Server passwords cannot begin with a colon");
    else if (strchr(yyvsp[-1].string, ' ') != NULL)
      yyerror("Server passwords cannot contain spaces");
    else {
      if (yy_aconf->spasswd != NULL)
        memset(yy_aconf->spasswd, 0, strlen(yy_aconf->spasswd));

      MyFree(yy_aconf->spasswd);
      DupString(yy_aconf->spasswd, yylval.string);
    }
  }
}
break;
case 412:
#line 2573 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yyvsp[-1].string[0] == ':')
      yyerror("Server passwords cannot begin with a colon");
    else if (strchr(yyvsp[-1].string, ' ') != NULL)
      yyerror("Server passwords cannot contain spaces");
    else {
      if (yy_aconf->passwd != NULL)
        memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

      MyFree(yy_aconf->passwd);
      DupString(yy_aconf->passwd, yylval.string);
    }
  }
}
break;
case 413:
#line 2591 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->port = yyvsp[-1].number;
}
break;
case 414:
#line 2597 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->aftype = AF_INET;
}
break;
case 415:
#line 2601 "ircd_parser.y"
{
#ifdef IPV6
  if (ypass == 2)
    yy_aconf->aftype = AF_INET6;
#endif
}
break;
case 416:
#line 2609 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->fakename);
    DupString(yy_aconf->fakename, yylval.string);
  }
}
break;
case 417:
#line 2618 "ircd_parser.y"
{
}
break;
case 421:
#line 2622 "ircd_parser.y"
{ not_atom = 1; }
break;
case 423:
#line 2623 "ircd_parser.y"
{ not_atom = 0; }
break;
case 425:
#line 2626 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfLazyLink(yy_aconf);
    else SetConfLazyLink(yy_aconf);
  }
}
break;
case 426:
#line 2633 "ircd_parser.y"
{
  if (ypass == 2)
#ifndef HAVE_LIBZ
    yyerror("Ignoring flags = compressed; -- no zlib support");
#else
 {
   if (not_atom)ClearConfCompressed(yy_aconf);
   else SetConfCompressed(yy_aconf);
 }
#endif
}
break;
case 427:
#line 2644 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfCryptLink(yy_aconf);
    else SetConfCryptLink(yy_aconf);
  }
}
break;
case 428:
#line 2651 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfAllowAutoConn(yy_aconf);
    else SetConfAllowAutoConn(yy_aconf);
  }
}
break;
case 429:
#line 2658 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfAwayBurst(yy_aconf);
    else SetConfAwayBurst(yy_aconf);
  }
}
break;
case 430:
#line 2665 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfTopicBurst(yy_aconf);
    else SetConfTopicBurst(yy_aconf);
  }
}
break;
case 431:
#line 2675 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (yy_aconf->rsa_public_key != NULL)
    {
      RSA_free(yy_aconf->rsa_public_key);
      yy_aconf->rsa_public_key = NULL;
    }

    if (yy_aconf->rsa_public_key_file != NULL)
    {
      MyFree(yy_aconf->rsa_public_key_file);
      yy_aconf->rsa_public_key_file = NULL;
    }

    DupString(yy_aconf->rsa_public_key_file, yylval.string);

    if ((file = BIO_new_file(yylval.string, "r")) == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- file doesn't exist");
      break;
    }

    yy_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, NULL, 0, NULL);

    if (yy_aconf->rsa_public_key == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- Key invalid; check key syntax.");
      break;
    }
      
    BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif /* HAVE_LIBCRYPTO */
}
break;
case 432:
#line 2716 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ENCRYPTED;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ENCRYPTED;
  }
}
break;
case 433:
#line 2727 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_CRYPTLINK;
    else
      yy_aconf->flags &= ~CONF_FLAGS_CRYPTLINK;
  }
}
break;
case 434:
#line 2738 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
#ifndef HAVE_LIBZ
      yyerror("Ignoring compressed=yes; -- no zlib support");
#else
      yy_aconf->flags |= CONF_FLAGS_COMPRESSED;
#endif
    else
      yy_aconf->flags &= ~CONF_FLAGS_COMPRESSED;
  }
}
break;
case 435:
#line 2753 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ALLOW_AUTO_CONN;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ALLOW_AUTO_CONN;
  }
}
break;
case 436:
#line 2764 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
    DupString(yy_tmp->host, yylval.string);
    DupString(yy_tmp->user, "*");
    dlinkAdd(yy_tmp, &yy_tmp->node, &hub_conf_list);
  }
}
break;
case 437:
#line 2777 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
    DupString(yy_tmp->host, yylval.string);
    DupString(yy_tmp->user, "*");
    dlinkAdd(yy_tmp, &yy_tmp->node, &leaf_conf_list);
  }
}
break;
case 438:
#line 2790 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 439:
#line 2799 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    struct EncCapability *ecap;
    const char *cipher_name;
    int found = 0;

    yy_aconf->cipher_preference = NULL;
    cipher_name = yylval.string;

    for (ecap = CipherTable; ecap->name; ecap++)
    {
      if ((irccmp(ecap->name, cipher_name) == 0) &&
          (ecap->cap & CAP_ENC_MASK))
      {
        yy_aconf->cipher_preference = ecap;
        found = 1;
        break;
      }
    }

    if (!found)
      yyerror("Invalid cipher");
  }
#else
  if (ypass == 2)
    yyerror("Ignoring cipher_preference -- no OpenSSL support");
#endif
}
break;
case 440:
#line 2834 "ircd_parser.y"
{
  if (ypass == 2)
  {
    userbuf[0] = hostbuf[0] = reasonbuf[0] = '\0';
    regex_ban = 0;
  }
}
break;
case 441:
#line 2841 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (userbuf[0] && hostbuf[0])
    {
      if (regex_ban)
      {
        pcre *exp_user = NULL;
        pcre *exp_host = NULL;
        const char *errptr = NULL;

        if (!(exp_user = ircd_pcre_compile(userbuf, &errptr)) ||
            !(exp_host = ircd_pcre_compile(hostbuf, &errptr)))
        {
          ilog(L_ERROR, "Failed to add regular expression based K-Line: %s", errptr);
          break;
        }

        yy_conf = make_conf_item(RKLINE_TYPE);
        yy_aconf->regexuser = exp_user;
        yy_aconf->regexhost = exp_host;

        DupString(yy_aconf->user, userbuf);
        DupString(yy_aconf->host, hostbuf);

        if (reasonbuf[0])
          DupString(yy_aconf->reason, reasonbuf);
        else
          DupString(yy_aconf->reason, "No reason");
      }
      else
      {
        yy_conf = make_conf_item(KLINE_TYPE);
        yy_aconf = &yy_conf->conf.AccessItem;

        DupString(yy_aconf->user, userbuf);
        DupString(yy_aconf->host, hostbuf);

        if (reasonbuf[0])
          DupString(yy_aconf->reason, reasonbuf);
        else
          DupString(yy_aconf->reason, "No reason");
        add_conf_by_address(CONF_KILL, yy_aconf);
      }
    }
    else
      delete_conf_item(yy_conf);

    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 442:
#line 2895 "ircd_parser.y"
{
}
break;
case 446:
#line 2900 "ircd_parser.y"
{
  if (ypass == 2)
    regex_ban = 1;
}
break;
case 453:
#line 2909 "ircd_parser.y"
{
  if (ypass == 2)
  {
    char *user = NULL, *host = NULL;

    split_nuh(yylval.string, NULL, &user, &host);

    strlcpy(userbuf, user, sizeof(userbuf));
    strlcpy(hostbuf, host, sizeof(hostbuf));

    MyFree(user);
    MyFree(host);
  }
}
break;
case 454:
#line 2925 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(reasonbuf, yylval.string, sizeof(reasonbuf));
}
break;
case 455:
#line 2934 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(DLINE_TYPE);
    yy_aconf = &yy_conf->conf.AccessItem;
    /* default reason */
    DupString(yy_aconf->reason, "No reason");
  }
}
break;
case 456:
#line 2943 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->host && parse_netmask(yy_aconf->host, NULL, NULL) != HM_HOST)
      add_conf_by_address(CONF_DLINE, yy_aconf);
    else
      delete_conf_item(yy_conf);
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 462:
#line 2959 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 463:
#line 2968 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->reason);
    DupString(yy_aconf->reason, yylval.string);
  }
}
break;
case 469:
#line 2985 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.string[0] && parse_netmask(yylval.string, NULL, NULL) != HM_HOST)
    {
      yy_conf = make_conf_item(EXEMPTDLINE_TYPE);
      yy_aconf = &yy_conf->conf.AccessItem;
      DupString(yy_aconf->host, yylval.string);

      add_conf_by_address(CONF_EXEMPTDLINE, yy_aconf);

      yy_conf = NULL;
      yy_aconf = NULL;
    }
  }
}
break;
case 470:
#line 3006 "ircd_parser.y"
{
  if (ypass == 2)
  {
    regex_ban = 0;
    reasonbuf[0] = gecos_name[0] = '\0';
  }
}
break;
case 471:
#line 3013 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (gecos_name[0])
    {
      if (regex_ban)
      {
        pcre *exp_p = NULL;
        const char *errptr = NULL;

        if (!(exp_p = ircd_pcre_compile(gecos_name, &errptr)))
        {
          ilog(L_ERROR, "Failed to add regular expression based X-Line: %s", errptr);
          break;
        }

        yy_conf = make_conf_item(RXLINE_TYPE);
        yy_conf->regexpname = exp_p;
      }
      else
        yy_conf = make_conf_item(XLINE_TYPE);

      yy_match_item = &yy_conf->conf.MatchItem;
      DupString(yy_conf->name, gecos_name);

      if (reasonbuf[0])
        DupString(yy_match_item->reason, reasonbuf);
      else
        DupString(yy_match_item->reason, "No reason");
    }
  }
}
break;
case 472:
#line 3047 "ircd_parser.y"
{
}
break;
case 476:
#line 3052 "ircd_parser.y"
{
  if (ypass == 2)
    regex_ban = 1;
}
break;
case 483:
#line 3061 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(gecos_name, yylval.string, sizeof(gecos_name));
}
break;
case 484:
#line 3067 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(reasonbuf, yylval.string, sizeof(reasonbuf));
}
break;
case 544:
#line 3111 "ircd_parser.y"
{
  ConfigFileEntry.max_watch = yylval.number;
}
break;
case 545:
#line 3116 "ircd_parser.y"
{
  ConfigFileEntry.gline_min_cidr = yyvsp[-1].number;
}
break;
case 546:
#line 3121 "ircd_parser.y"
{
  ConfigFileEntry.gline_min_cidr6 = yyvsp[-1].number;
}
break;
case 547:
#line 3126 "ircd_parser.y"
{
  ConfigFileEntry.burst_away = yylval.number;
}
break;
case 548:
#line 3131 "ircd_parser.y"
{
  ConfigFileEntry.use_whois_actually = yylval.number;
}
break;
case 549:
#line 3136 "ircd_parser.y"
{
  GlobalSetOptions.rejecttime = yylval.number;
}
break;
case 550:
#line 3141 "ircd_parser.y"
{
  ConfigFileEntry.tkline_expire_notices = yylval.number;
}
break;
case 551:
#line 3146 "ircd_parser.y"
{
  ConfigFileEntry.kill_chase_time_limit = yyvsp[-1].number;
}
break;
case 552:
#line 3151 "ircd_parser.y"
{
  ConfigFileEntry.hide_spoof_ips = yylval.number;
}
break;
case 553:
#line 3156 "ircd_parser.y"
{
  ConfigFileEntry.ignore_bogus_ts = yylval.number;
}
break;
case 554:
#line 3161 "ircd_parser.y"
{
  ConfigFileEntry.disable_remote = yylval.number;
}
break;
case 555:
#line 3166 "ircd_parser.y"
{
  ConfigFileEntry.failed_oper_notice = yylval.number;
}
break;
case 556:
#line 3171 "ircd_parser.y"
{
  ConfigFileEntry.anti_nick_flood = yylval.number;
}
break;
case 557:
#line 3176 "ircd_parser.y"
{
  ConfigFileEntry.max_nick_time = yyvsp[-1].number; 
}
break;
case 558:
#line 3181 "ircd_parser.y"
{
  ConfigFileEntry.max_nick_changes = yyvsp[-1].number;
}
break;
case 559:
#line 3186 "ircd_parser.y"
{
  ConfigFileEntry.max_accept = yyvsp[-1].number;
}
break;
case 560:
#line 3191 "ircd_parser.y"
{
  ConfigFileEntry.anti_spam_exit_message_time = yyvsp[-1].number;
}
break;
case 561:
#line 3196 "ircd_parser.y"
{
  ConfigFileEntry.ts_warn_delta = yyvsp[-1].number;
}
break;
case 562:
#line 3201 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.ts_max_delta = yyvsp[-1].number;
}
break;
case 563:
#line 3207 "ircd_parser.y"
{
  if ((yyvsp[-1].number > 0) && ypass == 1)
  {
    ilog(L_CRIT, "You haven't read your config file properly.");
    ilog(L_CRIT, "There is a line in the example conf that will kill your server if not removed.");
    ilog(L_CRIT, "Consider actually reading/editing the conf file, and removing this line.");
    exit(0);
  }
}
break;
case 564:
#line 3218 "ircd_parser.y"
{
  ConfigFileEntry.kline_with_reason = yylval.number;
}
break;
case 565:
#line 3223 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.kline_reason);
    DupString(ConfigFileEntry.kline_reason, yylval.string);
  }
}
break;
case 566:
#line 3232 "ircd_parser.y"
{
  ConfigFileEntry.invisible_on_connect = yylval.number;
}
break;
case 567:
#line 3237 "ircd_parser.y"
{
  ConfigFileEntry.warn_no_nline = yylval.number;
}
break;
case 568:
#line 3242 "ircd_parser.y"
{
  ConfigFileEntry.stats_o_oper_only = yylval.number;
}
break;
case 569:
#line 3247 "ircd_parser.y"
{
  ConfigFileEntry.stats_P_oper_only = yylval.number;
}
break;
case 570:
#line 3252 "ircd_parser.y"
{
  ConfigFileEntry.stats_k_oper_only = 2 * yylval.number;
}
break;
case 571:
#line 3255 "ircd_parser.y"
{
  ConfigFileEntry.stats_k_oper_only = 1;
}
break;
case 572:
#line 3260 "ircd_parser.y"
{
  ConfigFileEntry.stats_i_oper_only = 2 * yylval.number;
}
break;
case 573:
#line 3263 "ircd_parser.y"
{
  ConfigFileEntry.stats_i_oper_only = 1;
}
break;
case 574:
#line 3268 "ircd_parser.y"
{
  ConfigFileEntry.pace_wait = yyvsp[-1].number;
}
break;
case 575:
#line 3273 "ircd_parser.y"
{
  ConfigFileEntry.caller_id_wait = yyvsp[-1].number;
}
break;
case 576:
#line 3278 "ircd_parser.y"
{
  ConfigFileEntry.opers_bypass_callerid = yylval.number;
}
break;
case 577:
#line 3283 "ircd_parser.y"
{
  ConfigFileEntry.pace_wait_simple = yyvsp[-1].number;
}
break;
case 578:
#line 3288 "ircd_parser.y"
{
  ConfigFileEntry.short_motd = yylval.number;
}
break;
case 579:
#line 3293 "ircd_parser.y"
{
  ConfigFileEntry.no_oper_flood = yylval.number;
}
break;
case 580:
#line 3298 "ircd_parser.y"
{
  ConfigFileEntry.true_no_oper_flood = yylval.number;
}
break;
case 581:
#line 3303 "ircd_parser.y"
{
  ConfigFileEntry.oper_pass_resv = yylval.number;
}
break;
case 582:
#line 3308 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > LOCALE_LENGTH-2)
      yylval.string[LOCALE_LENGTH-1] = '\0';

    set_locale(yylval.string);
  }
}
break;
case 583:
#line 3319 "ircd_parser.y"
{
  ConfigFileEntry.idletime = yyvsp[-1].number;
}
break;
case 584:
#line 3324 "ircd_parser.y"
{
  ConfigFileEntry.dots_in_ident = yyvsp[-1].number;
}
break;
case 585:
#line 3329 "ircd_parser.y"
{
  ConfigFileEntry.max_targets = yyvsp[-1].number;
}
break;
case 586:
#line 3334 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.servlink_path);
    DupString(ConfigFileEntry.servlink_path, yylval.string);
  }
}
break;
case 587:
#line 3343 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    struct EncCapability *ecap;
    const char *cipher_name;
    int found = 0;

    ConfigFileEntry.default_cipher_preference = NULL;
    cipher_name = yylval.string;

    for (ecap = CipherTable; ecap->name; ecap++)
    {
      if ((irccmp(ecap->name, cipher_name) == 0) &&
          (ecap->cap & CAP_ENC_MASK))
      {
        ConfigFileEntry.default_cipher_preference = ecap;
        found = 1;
        break;
      }
    }

    if (!found)
      yyerror("Invalid cipher");
  }
#else
  if (ypass == 2)
    yyerror("Ignoring default_cipher_preference -- no OpenSSL support");
#endif
}
break;
case 588:
#line 3375 "ircd_parser.y"
{
  if (ypass == 2)
  {
    ConfigFileEntry.compression_level = yyvsp[-1].number;
#ifndef HAVE_LIBZ
    yyerror("Ignoring compression_level -- no zlib support");
#else
    if ((ConfigFileEntry.compression_level < 1) ||
        (ConfigFileEntry.compression_level > 9))
    {
      yyerror("Ignoring invalid compression_level, using default");
      ConfigFileEntry.compression_level = 0;
    }
#endif
  }
}
break;
case 589:
#line 3393 "ircd_parser.y"
{
  ConfigFileEntry.use_egd = yylval.number;
}
break;
case 590:
#line 3398 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.egdpool_path);
    DupString(ConfigFileEntry.egdpool_path, yylval.string);
  }
}
break;
case 591:
#line 3407 "ircd_parser.y"
{
  ConfigFileEntry.ping_cookie = yylval.number;
}
break;
case 592:
#line 3412 "ircd_parser.y"
{
  ConfigFileEntry.disable_auth = yylval.number;
}
break;
case 593:
#line 3417 "ircd_parser.y"
{
  ConfigFileEntry.throttle_time = yylval.number;
}
break;
case 594:
#line 3422 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes = 0;
}
break;
case 598:
#line 3428 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_BOTS;
}
break;
case 599:
#line 3431 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_CCONN;
}
break;
case 600:
#line 3434 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_DEAF;
}
break;
case 601:
#line 3437 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_DEBUG;
}
break;
case 602:
#line 3440 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_FULL;
}
break;
case 603:
#line 3443 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SKILL;
}
break;
case 604:
#line 3446 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_NCHANGE;
}
break;
case 605:
#line 3449 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_REJ;
}
break;
case 606:
#line 3452 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_UNAUTH;
}
break;
case 607:
#line 3455 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SPY;
}
break;
case 608:
#line 3458 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_EXTERNAL;
}
break;
case 609:
#line 3461 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_OPERWALL;
}
break;
case 610:
#line 3464 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SERVNOTICE;
}
break;
case 611:
#line 3467 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_INVISIBLE;
}
break;
case 612:
#line 3470 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_WALLOP;
}
break;
case 613:
#line 3473 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SOFTCALLERID;
}
break;
case 614:
#line 3476 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_CALLERID;
}
break;
case 615:
#line 3479 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_LOCOPS;
}
break;
case 616:
#line 3484 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes = 0;
}
break;
case 620:
#line 3490 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_BOTS;
}
break;
case 621:
#line 3493 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_CCONN;
}
break;
case 622:
#line 3496 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_DEAF;
}
break;
case 623:
#line 3499 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_DEBUG;
}
break;
case 624:
#line 3502 "ircd_parser.y"
{ 
  ConfigFileEntry.oper_only_umodes |= UMODE_FULL;
}
break;
case 625:
#line 3505 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SKILL;
}
break;
case 626:
#line 3508 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_NCHANGE;
}
break;
case 627:
#line 3511 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_REJ;
}
break;
case 628:
#line 3514 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_UNAUTH;
}
break;
case 629:
#line 3517 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SPY;
}
break;
case 630:
#line 3520 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_EXTERNAL;
}
break;
case 631:
#line 3523 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_OPERWALL;
}
break;
case 632:
#line 3526 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SERVNOTICE;
}
break;
case 633:
#line 3529 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_INVISIBLE;
}
break;
case 634:
#line 3532 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_WALLOP;
}
break;
case 635:
#line 3535 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SOFTCALLERID;
}
break;
case 636:
#line 3538 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_CALLERID;
}
break;
case 637:
#line 3541 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_LOCOPS;
}
break;
case 638:
#line 3546 "ircd_parser.y"
{
  ConfigFileEntry.min_nonwildcard = yyvsp[-1].number;
}
break;
case 639:
#line 3551 "ircd_parser.y"
{
  ConfigFileEntry.min_nonwildcard_simple = yyvsp[-1].number;
}
break;
case 640:
#line 3556 "ircd_parser.y"
{
  ConfigFileEntry.default_floodcount = yyvsp[-1].number;
}
break;
case 641:
#line 3561 "ircd_parser.y"
{
  ConfigFileEntry.client_flood = yyvsp[-1].number;
}
break;
case 642:
#line 3566 "ircd_parser.y"
{
  ConfigFileEntry.dot_in_ip6_addr = yylval.number;
}
break;
case 643:
#line 3574 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(GDENY_TYPE);
    yy_aconf = &yy_conf->conf.AccessItem;
  }
}
break;
case 644:
#line 3581 "ircd_parser.y"
{
  if (ypass == 2)
  {
    /*
     * since we re-allocate yy_conf/yy_aconf after the end of action=, at the
     * end we will have one extra, so we should free it.
     */
    if (yy_conf->name == NULL || yy_aconf->user == NULL)
    {
      delete_conf_item(yy_conf);
      yy_conf = NULL;
      yy_aconf = NULL;
    }
  }
}
break;
case 654:
#line 3607 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.glines = yylval.number;
}
break;
case 655:
#line 3613 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_time = yyvsp[-1].number;
}
break;
case 656:
#line 3619 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging = 0;
}
break;
case 660:
#line 3625 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging |= GDENY_REJECT;
}
break;
case 661:
#line 3629 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging |= GDENY_BLOCK;
}
break;
case 662:
#line 3635 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->user == NULL)
    {
      split_nuh(yylval.string, NULL, &yy_aconf->user, &yy_aconf->host);
    }
    else
    {
      struct CollectItem *yy_tmp = MyMalloc(sizeof(struct CollectItem));
      split_nuh(yylval.string, NULL, &yy_tmp->user, &yy_tmp->host);
      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 663:
#line 3652 "ircd_parser.y"
{
  if (ypass == 2)  
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 664:
#line 3661 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags = 0;
}
break;
case 665:
#line 3665 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp = NULL;
    dlink_node *ptr = NULL, *next_ptr = NULL;

    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;

      yy_tmp = ptr->data;
      new_conf = make_conf_item(GDENY_TYPE);
      new_aconf = &new_conf->conf.AccessItem;

      new_aconf->flags = yy_aconf->flags;

      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      else
        DupString(new_conf->name, "*");
      if (yy_aconf->user != NULL)
         DupString(new_aconf->user, yy_tmp->user);
      else   
        DupString(new_aconf->user, "*");
      if (yy_aconf->host != NULL)
        DupString(new_aconf->host, yy_tmp->host);
      else
        DupString(new_aconf->host, "*");

      dlinkDelete(&yy_tmp->node, &col_conf_list);
    }

    /*
     * In case someone has fed us with more than one action= after user/name
     * which would leak memory  -Michael
     */
    if (yy_conf->name == NULL || yy_aconf->user == NULL)
      delete_conf_item(yy_conf);

    yy_conf = make_conf_item(GDENY_TYPE);
    yy_aconf = &yy_conf->conf.AccessItem;
  }
}
break;
case 668:
#line 3712 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= GDENY_REJECT;
}
break;
case 669:
#line 3716 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= GDENY_BLOCK;
}
break;
case 691:
#line 3740 "ircd_parser.y"
{
  ConfigChannel.restrict_channels = yylval.number;
}
break;
case 692:
#line 3745 "ircd_parser.y"
{
  ConfigChannel.disable_local_channels = yylval.number;
}
break;
case 693:
#line 3750 "ircd_parser.y"
{
  ConfigChannel.use_except = yylval.number;
}
break;
case 694:
#line 3755 "ircd_parser.y"
{
  ConfigChannel.use_invex = yylval.number;
}
break;
case 695:
#line 3760 "ircd_parser.y"
{
  ConfigChannel.use_knock = yylval.number;
}
break;
case 696:
#line 3765 "ircd_parser.y"
{
  ConfigChannel.knock_delay = yyvsp[-1].number;
}
break;
case 697:
#line 3770 "ircd_parser.y"
{
  ConfigChannel.knock_delay_channel = yyvsp[-1].number;
}
break;
case 698:
#line 3775 "ircd_parser.y"
{
  ConfigChannel.max_chans_per_user = yyvsp[-1].number;
}
break;
case 699:
#line 3780 "ircd_parser.y"
{
  ConfigChannel.quiet_on_ban = yylval.number;
}
break;
case 700:
#line 3785 "ircd_parser.y"
{
  ConfigChannel.max_bans = yyvsp[-1].number;
}
break;
case 701:
#line 3790 "ircd_parser.y"
{
  ConfigChannel.default_split_user_count = yyvsp[-1].number;
}
break;
case 702:
#line 3795 "ircd_parser.y"
{
  ConfigChannel.default_split_server_count = yyvsp[-1].number;
}
break;
case 703:
#line 3800 "ircd_parser.y"
{
  ConfigChannel.no_create_on_split = yylval.number;
}
break;
case 704:
#line 3805 "ircd_parser.y"
{
  ConfigChannel.no_join_on_split = yylval.number;
}
break;
case 705:
#line 3810 "ircd_parser.y"
{
  ConfigChannel.burst_topicwho = yylval.number;
}
break;
case 706:
#line 3815 "ircd_parser.y"
{
  GlobalSetOptions.joinfloodcount = yylval.number;
}
break;
case 707:
#line 3820 "ircd_parser.y"
{
  GlobalSetOptions.joinfloodtime = yylval.number;
}
break;
case 719:
#line 3839 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.flatten_links = yylval.number;
}
break;
case 720:
#line 3845 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hide_servers = yylval.number;
}
break;
case 721:
#line 3851 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigServerHide.hidden_name);
    DupString(ConfigServerHide.hidden_name, yylval.string);
  }
}
break;
case 722:
#line 3860 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if ((yyvsp[-1].number > 0) && ConfigServerHide.links_disabled == 1)
    {
      eventAddIsh("write_links_file", write_links_file, NULL, yyvsp[-1].number);
      ConfigServerHide.links_disabled = 0;
    }

    ConfigServerHide.links_delay = yyvsp[-1].number;
  }
}
break;
case 723:
#line 3874 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hidden = yylval.number;
}
break;
case 724:
#line 3880 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.disable_hidden = yylval.number;
}
break;
case 725:
#line 3886 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hide_server_ips = yylval.number;
}
break;
#line 6214 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
